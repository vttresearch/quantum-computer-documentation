{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the VTT Q5 documentation","text":"<p>This website contains the technical documentation about VTT's Quantum Computers and how to access them. Currently we provide access to VTT Q5, a 5 qubit superconducting quantum computer, also named \"Helmi\". Access to Helmi is currently provided through the EuroHPC Supercomputer LUMI, operated by CSC.</p> <ul> <li>Companies can get access to Helmi here.</li> <li>Academic researchers can get access to Helmi by following the instructions here.</li> </ul> <p>Once you have a project, the next steps can be found on the Accessing LUMI page.</p>"},{"location":"#additional-links","title":"Additional links","text":"<ul> <li>CSC Documentation</li> <li>LUMI Documentation</li> <li>Finland's first quantum computer opened for companies Press release</li> </ul>"},{"location":"calibration/","title":"Calibration","text":"<p>Helmi is continously calibrated to ensure functionality. The calibration process involves a series of experiments, aimed at fine-tuning the parameters, necessary for controlling and measuring the qubits. In addition to calibration, we run benchmarks to obtain the figures of merit reflecting the current state of the quantum computer.</p> <p>Note</p> <p>Calibration and benchmarking experiments are interleaved with regular user jobs in Helmi's job queue, as detailed in the Running on Helmi section. The calibration might therefore slightly increase the waiting time in the queue of regular user jobs.</p>"},{"location":"calibration/#calibration-sequences","title":"Calibration sequences","text":"<p>To minimize the impact of calibration on user operations, we execute shorter calibration sequences during the day and a longer calibration run throughout the night.</p> <p>Short calibration:</p> <ul> <li>Every 2 hours from 11 am to 11 pm</li> <li>Adjusts qubit drive frequency, drive amplitude and readout threshold</li> <li>Measures \\(T_1\\), \\(T_2\\), \\(T_2^*\\) and readout accuracy</li> </ul> <p>Extended calibration:</p> <ul> <li>Every day at 4 am</li> <li>Adjusts qubit drive frequency, amplitude fine-tuning and readout threshold</li> <li>Measures \\(T_1\\), \\(T_2\\), \\(T_2^*\\), readout accuracy, single- and two-qubit gate fidelities</li> </ul>"},{"location":"calibration/#figures-of-merit","title":"Figures of Merit","text":"<p>The benchmarks results are summarized in the calibration set representing the figures of merit and reflecting the latest state of the quantum computer. The calibration set can be fetched from Helmi's API. An example script is provided here. Each calibration set is identified via a unique ID. A new calibration set ID is created after each calibration. Note, that not all metrics are updated after each calibration run. We recommend to save the current calibration set ID together with the job ID to facilitate debugging and analysis.</p> <p>The metrics contained in the calibration set are summarized below:</p> Metric Description \\(T_1\\) time (s) The \\(T_1\\) time is called the longitudinal relaxation rate and describes how quickly the excited state of the qubit returns to its ground state. \\(T_2\\) time (s) The \\(T_2\\) time is called the transverse relaxation rate and describes loss of coherence of a superposition state. \\(T_2\\)-echo time (s) The \\(T_2\\)-echo time describes the loss of coherence of the superposition state of the qubit. It is more precise than the T2 Time as it is less susceptible to low-frequency noise. Single-shot readout fidelity Measures the average accuracy of distinguishing qubit states. The experiment prepares for 50% of the shots the qubit in the ground state \\(| 0\\rangle\\) and for the other 50% in the excited state \\(| 1\\rangle\\). Single-shot readout 10 error The error in labelling the qubit state as \\(| 0\\rangle\\) when it was prepared in state \\(| 1\\rangle\\) Single-shot readout 01 error The error in labelling the qubit state as \\(| 1\\rangle\\) when it was prepared in state \\(| 0\\rangle\\) 1QB average gate fidelity Average 1QB gate fidelity estimated with randomized benchmarking. 2QB average gate fidelity The average 2QB gate fidelity estimated with randomized benchmarking. CZ gate fidelity The average CZ gate fidelity estimated with interleaved randomized benchmarking. It is usually higher than the average 2QB gate fidelity as a random 2QB Clifford transpiles on average to 8 1QB gates and 1.5 CZ gates. <p>These metrics provide critical insights into the operational efficiency, error rates, and coherence properties of Helmi. Understanding these figures of merit allows a user to make informed decisions on transpilation strategies and qubit selection, optimizing for circuit depth or fidelity.</p>"},{"location":"faq/","title":"FAQ","text":"<p>Q: Does the name \"Helmi\" have a meaning?</p> <p>Helmi is the Finnish word for pearl.</p> <p>Q: Does Helmi provide pulse-level access?</p> <p>Currently, we only provide circuit-level access.</p> <p>Q: Is there any optimization applied during gate-to-pulse compilation?</p> <p>No circuit optimization is performed after the circuit has been submitted in serialized form with the IQM client. The gate-to-pulse compiler replaces each gate by the corresponding pulse and submits the pulses to the backend for execution.</p> <p>Q: Is heralding enabled on Helmi?</p> <p>Heralding is an optional feature that allows for post-selection of shots, to filter out runs where one or more qubits were not in the ground state at the beginning of the circuit execution. The feature is currently unavailable on Helmi.</p> <p>Q: What is the time-to-execution after a job has been scheduled on Helmi?</p> <p>An overhead of 10 seconds can be expected. The largest overhead is introduced by compiling the pulses to instructions for the control electronics and the upload to the instruments.</p> <p>Q: Does the number of shots affect the calibration of Helmi?</p> <p>No, a large number of shots will not cause thermal excitations of the qubits.</p> <p>Q: Can Pennylane be used on Helmi?</p> <p>Yes, Pennylane can be used on Helmi through a fork of the Pennylane-Qiskit package. This is demonstrated in the Introduction to Helmi with Qiskit example.</p>"},{"location":"helmi/","title":"VTT Q5 \"Helmi\"","text":"<p>VTT Q5 is a 5 qubit superconducting quantum computer computer co-developed and built by IQM and VTT. It uses flux-tunable qubits and couplers which are described in this paper<sup>1</sup>.</p> <p>Helmi's qubits are arranged in a star-shaped topology, meaning that the central qubit, QB3, is connected to all of the outer qubits, QB1, QB2, QB4. Two-qubit gates can be applied only between the central qubit and the outer qubits.</p> <p> VTT Q5 star-shaped topology</p> <p>The qubits are pairwise connected with tunable couplers.</p>"},{"location":"helmi/#native-gate-set","title":"Native-gate set","text":"<p>To run arbitrary quantum circuits, a QPU needs to implement a universal gate set. Helmi implements the following gates natively:</p> <ul> <li>Single-qubit gates: Phased-\\(RX\\) gate (PRX)</li> <li>Two-qubit gate: Controlled-\\(Z\\) gate (CZ)</li> </ul> <p>Measurements are natively implemented as single-qubit measurements in the \\(Z\\) basis.</p>"},{"location":"helmi/#characteristics","title":"Characteristics","text":"<p>The values below are averaged values. Actual values might differ from day-to-day.</p> QB1 QB2 QB3 QB4 QB5 Drive Frequencies [GHz] 4.4 3.9 4.2 4.4 4.4 Readout Frequencies [GHz] 5.3 5.0 6.2 5.9 5.6 T1 time [\u00b5s] 35.5 25.7 40.2 41.3 36.0 T2 time [\u00b5s] 19.2 17.7 9.12 19.1 22.2 T2 echo time [\u00b5s] 45.2 33.1 26.5 47.7 35.0 Single-Qubit Gate Fidelities<sup>2</sup> [%] 99.4 99.7 99.7 99.6 99.7 Readout Fidelities [%] 96 95 95 95 95 <p>The coupler characteristics are given below. TC refers to tunable coupler.</p> TC-3-1 TC-3-2 TC-3-4 TC-3-5 Two-qubit Gate Fidelities<sup>3</sup> [%] 96.4 95.9 94.6 97.5 <p>The PRX gate length and the CZ gate length is 120 [ns] respectively.</p> <ol> <li> <p>Long-Distance Transmon Coupler with cz-Gate Fidelity above 99.8%, Marxer et al. \u21a9</p> </li> <li> <p>Calculated via randomized benchmarking\u00a0\u21a9</p> </li> <li> <p>CZ gate fidelity calculated via interleaved randomized benchmarking\u00a0\u21a9</p> </li> </ol>"},{"location":"limitations/","title":"Limitations","text":"<p>There are a number of limitations on Helmi that need to be taken into account when writing quantum circuits.</p> <p>Queue length</p> <p>To ensure manageable wait times, the job queue can accommodate up to 100 concurrent jobs. Jobs when the queue reached its limit will be denied, triggering the following error message from the IQM client:</p> <pre><code>ClientAuthenticationError: Authentication failed: {\"detail\":\"Job rejected: Too many circuits in queue\"}\n</code></pre> <p>Batch size</p> <p>On our Helmi system, quantum circuits within a batch are processed sequentially. To prevent extensive queue occupation by large batches, we have set a maximum limit of 20 circuits per batch. Jobs submitting batches with more than 20 circuits will be rejected and the IQM client will return the following error</p> <pre><code>ClientAuthenticationError: Authentication failed: {\"detail\":\"Too many circuits X in batch (max: 20)\"}\n</code></pre> <p>Here, 'X' denotes the actual number of circuits attempted to be included in the batch.</p> <p>Number of shots</p> <p>The execution time for a quantum circuit scales with the number of shots. To avoid disproportionately long job durations, we impose a threshold of 100,000 shots per circuit. Should your experiment require more shots, we recommend dividing it into multiple separate jobs. For cases where this shot limit proves inadequate, please do not hesitate to reach out to our support.</p>"},{"location":"lumi/","title":"Accessing LUMI","text":"<p>Before accessing LUMI you need to be added to a project in My CSC with your CSC account. Access to LUMI is currently only through the command line interface, with access provided over SSH. Users using LUMI should have some experience with the Linux command line and familiarity with HPC systems. To log on to LUMI, you will first need to add your ssh key on your My CSC profile section.</p> <p>The LUMI documentation offers a guide for creating SSH keypairs from which you should follow the instructions labeled \"With a Finnish allocation\".</p> <p>Note</p> <p>It might take a couple of hours until your public key is distributed to all LUMI nodes.</p> <p>Warning</p> <p>The private key should never be shared with anyone. It should only be stored on your local computer. Otherwise, anyone can steal the SSH key and impersonate you.</p> <p>Once your public SSH key is available on all login nodes, you can access LUMI using</p> <pre><code>ssh -i &lt;path-to-private-key&gt; &lt;username&gt;@lumi.csc.fi\n</code></pre> <p>The LUMI documentation provides further information on how to connect to LUMI. For an introduction to LUMI, its architecture, modules and software stack, take a look at the LUMI training materials.</p>"},{"location":"lumi/#storage","title":"Storage","text":"<p>LUMI uses a Linux based parallel filesystem, utilising lustre. Access to differents parts of the file system are based on the projects you are associated with. LUMI's storage areas and their intended use cases are described here.</p>"},{"location":"lumi/#configuring-the-environment","title":"Configuring the environment","text":"<p>To run quantum circuits on LUMI we need to load certain Python modules. Dependencies are managed via <code>modules</code>, which can be loaded.</p> <p>To load the required modules, after connecting to LUMI, run the following lines in your terminal</p> <pre><code>module use /appl/local/quantum/modulefiles\nmodule load helmi_qiskit  # or helmi_cirq\n</code></pre> <p>This commands can also be added to your <code>.bashrc</code> to save repetition. In case you are curious, you can explore other available modules via <code>module avail</code>.</p>"},{"location":"lumi/#using-a-custom-python-environment","title":"Using a custom Python environment","text":"<p>Loading <code>helmi_qiskit</code> or <code>helmi_cirq</code> on LUMI comes with a preconfigured Python environment for submitting jobs to Helmi. This environment can be replicated by users, by following the LUMI documentation on installing python packages. To access Helmi you will still need to load the <code>helmi_standard</code> module.</p> <p> Package Version iqm-client  &gt;=12.5 &lt; 13.0 qiskit-iqm &gt;=8.3 &lt; 9.0 cirq-iqm &gt;=11.9 &lt; 12.0 <p></p> <p>Newer versions of the above Python packages can be installed and may work with Helmi, however these are currently unsupported and may lead to errors.</p> <p>As an alternative to the above, Python packages can be installed on top of <code>helmi_qiskit</code> or <code>helmi_cirq</code> into the Python user install directory by specifying <code>python -m pip install --user whatsapp</code>. This, however, may lead to increased dependency conflicts.</p>"},{"location":"lumi/#submitting-jobs","title":"Submitting jobs","text":"<p>Once you have access to LUMI and have configured your environment you can learn how to run jobs on Helmi with the Running on Helmi.</p>"},{"location":"running/","title":"Running on Helmi","text":"<p>To run interactive jobs on LUMI the <code>srun</code> command can be used</p> <pre><code>srun --account=project_&lt;id&gt; -t 0:02:00 -c 1 -n 1 --partition q_industry python qiskit_flip.py\n</code></pre> <p>The command takes a number of arguments</p> <ul> <li><code>--account</code>: Unix group string which can be found in your MyCSC project.</li> <li><code>-t</code>: Sets a limit on total run time of job allocation. Upper bound is 15 minutes.</li> <li><code>-c</code>: Requests that \\(n\\) CPUs be allocated per process.</li> <li><code>-n</code>: Number of tasks to run in parallel. If greater than 1, a job may be assigned to multiple nodes.</li> <li><code>--partition</code>: The partition to run on. Should be <code>q_industry</code>.</li> <li><code>cmd</code>: The command to run. In this case <code>python qiskit_flip.py</code></li> </ul> <p>Note, that the <code>srun</code> command is blocking, which means that you'll have to wait until your program terminates before <code>srun</code> returns and you can enter your next command. Alternatively you can also load a shell on the compute node to provide more flexibility. This can be done with the following command:</p> <pre><code>srun --account=project_&lt;id&gt; -t 0:15:00 -c 1 -n 1 --partition q_industry --pty bash\n</code></pre> <p>This command loads a bash shell on the compute node with access to Helmi. After getting the shell, you may need to load your modules again.</p> <p>Note</p> <p>The LUMI Web-interface is now available at www.lumi.csc.fi. You can run jupyter-notebooks through this web interface. See the section below for further details.</p> <p>To run longer experiments, it is advisable to use <code>sbatch</code> which executes batch jobs on LUMI.</p> <pre><code>#!/bin/bash\n\n#SBATCH --job-name=helmijob     # Job name\n#SBATCH --account=project_&lt;id&gt;  # Project for billing\n#SBATCH --partition=q_industry  # Partition (queue) name\n#SBATCH --ntasks=1              # One task (process)\n#SBATCH --cpus-per-task=1       # Number of cores (threads)\n#SBATCH --time=00:15:00         # Run time (hh:mm:ss)\n\nmodule use /appl/local/quantum/modulefiles\n\n# uncomment correct line:\n# module load helmi_qiskit\n# or\n# module load helmi_cirq\n\npython your_python_script.py\n</code></pre>"},{"location":"running/#job-queues","title":"Job queues","text":"<p>Running on Helmi through LUMI involves using two queues. The first one is the SLURM queue on LUMI. Users interact with SLURM using the <code>srun</code> or <code>sbatch</code> commands for job submission and can fetch details about the queue state using <code>squeue -p &lt;partition&gt;</code>. The state of the partition can be viewed with <code>sinfo -p &lt;partition&gt;</code>.</p> <p>Jobs on LUMI have the following limitations</p> <ul> <li>Maximum duration for any job is 15 minutes</li> <li>Maximum of 32 cores</li> </ul> <p>After your job is accepted by LUMI, it will be allocated to a node within the <code>q_industry</code> partition. At present, the <code>nid002153</code> node is available for use, which is equipped with 128 CPU cores and 256 GiB of memory.</p> <p>Note</p> <p>For additional information:</p> <ul> <li>To check the <code>q_industry</code> partition's current limits and the list of nodes, use <code>sinfo -s q_industry</code>.</li> <li>To obtain information about the node <code>nid002153</code>, use <code>scontrol show node \"nid002153\"</code>.</li> </ul> <p>The second queue is Helmi's internal job queue. It consists of a simple first-in-first-out (FIFO) queue. Each job from LUMI that executes a quantum circuit on Helmi will be inserted into this queue. It's important to note that operations that retrieve data, such as shot results or calibration data, do not enter this queue. Furthermore, periodic calibration jobs, submitted from VTT's side, are interleaved with regular user jobs in Helmi's queue (see Calibration) as depicted in the picture below.</p> <p></p>"},{"location":"running/#web-interface","title":"Web-interface","text":"<p>The LUMI Web interface allows users to run on Helmi through their browser and use Jupyter notebooks for execution. Here is a brief guide, specifically for Helmi, however further details can be found here.</p> <p>Once you have logged in select the <code>Jupyter</code> option. The session should be configured by selecting your project and the partition. The partitions should be <code>q_fiqci</code> and  <code>q_industry</code> for use with Helmi. The resource limitations are described here. For use with Helmi some custom advanced settings should be configured.</p> <pre><code>module use /appl/local/quantum/modulefiles\nmodule load helmi_qiskit\n</code></pre> <p>This pictures below demonstrate the process.</p> <p></p> <p></p>"},{"location":"support/","title":"Support","text":"<p>For technical assistance in accessing LUMI or Helmi or running jobs on Helmi please contact servicedesk@csc.fi.</p>"},{"location":"examples/","title":"Examples","text":"<p>Here you will find a list of examples of using VTT's Quantum computers. Additional examples can also be found in the FiQCI examples page.</p>"},{"location":"examples/#general","title":"General","text":"<ul> <li>Introduction to Helmi with Qiskit</li> <li>Introduction to Helmi with Cirq</li> </ul>"},{"location":"examples/intro-to-helmi-cirq/","title":"Introduction to Helmi with Cirq","text":"In\u00a0[\u00a0]: Copied! <pre>import cirq\nfrom cirq.contrib.svg import SVGCircuit\n\nfrom iqm.cirq_iqm.iqm_sampler import IQMSampler\nfrom iqm.cirq_iqm.optimizers import simplify_circuit\nimport networkx as nx\nimport numpy as np\nimport matplotlib.pyplot as plt\n</pre> import cirq from cirq.contrib.svg import SVGCircuit  from iqm.cirq_iqm.iqm_sampler import IQMSampler from iqm.cirq_iqm.optimizers import simplify_circuit import networkx as nx import numpy as np import matplotlib.pyplot as plt <p>Then connection to the backend is simple! For this we point the <code>IQMSampler</code> at what is called \"cocos URL\". The cocos url to access Helmi is provided below.</p> In\u00a0[\u00a0]: Copied! <pre>sampler = IQMSampler(\"https://qc.vtt.fi/helmi/cocos\")\ndevice = sampler.device\n</pre> sampler = IQMSampler(\"https://qc.vtt.fi/helmi/cocos\") device = sampler.device <p>We can also specify a <code>calibration_set_id</code> and whether to run with <code>circuit_duration_check</code> or not. The <code>circuit_duration_check</code> option when set to <code>True</code> disqualifies any circuits that are too long compared to the coherence time of the qubits.</p> In\u00a0[\u00a0]: Copied! <pre>sampler = IQMSampler(\"https://qc.vtt.fi/helmi/cocos\", calibration_set_id=\"c5a5e2d1-100b-42d4-a4fd-a49edfb9d176\", circuit_duration_check=True, heralding_mode=\"zeros\")\n</pre> sampler = IQMSampler(\"https://qc.vtt.fi/helmi/cocos\", calibration_set_id=\"c5a5e2d1-100b-42d4-a4fd-a49edfb9d176\", circuit_duration_check=True, heralding_mode=\"zeros\") <p>Now that we have connected to Helmi, we can query for some information about Helmi!</p> In\u00a0[\u00a0]: Copied! <pre>print(f'Native operations: {device.metadata.gateset}')\nprint(f'Number of qubits: {device.qubits}')\nprint(f'Coupling map: {device.metadata.nx_graph.edges}')\n</pre> print(f'Native operations: {device.metadata.gateset}') print(f'Number of qubits: {device.qubits}') print(f'Coupling map: {device.metadata.nx_graph.edges}') <p>The topology can be visualized with <code>networkx</code>.</p> In\u00a0[\u00a0]: Copied! <pre>G = nx.Graph()\nG.add_edges_from(device.metadata.nx_graph.edges)\nnode_labels = {node: str(node) for node in G.nodes}\nnx.draw(G, labels=node_labels, node_color='skyblue', node_size=500, font_size=10, with_labels=True)\n</pre> G = nx.Graph() G.add_edges_from(device.metadata.nx_graph.edges) node_labels = {node: str(node) for node in G.nodes} nx.draw(G, labels=node_labels, node_color='skyblue', node_size=500, font_size=10, with_labels=True) In\u00a0[\u00a0]: Copied! <pre>q1, q2 = cirq.NamedQubit('Alice'), cirq.NamedQubit('Bob')\ncircuit = cirq.Circuit()\ncircuit.append(cirq.H(q1))\ncircuit.append(cirq.CNOT(q1, q2))\ncircuit.append(cirq.measure(q1, q2, key='m'))\n\nSVGCircuit(circuit)\n</pre> q1, q2 = cirq.NamedQubit('Alice'), cirq.NamedQubit('Bob') circuit = cirq.Circuit() circuit.append(cirq.H(q1)) circuit.append(cirq.CNOT(q1, q2)) circuit.append(cirq.measure(q1, q2, key='m'))  SVGCircuit(circuit) <p>First we'll transpile the circuit into Helmi's native gates</p> In\u00a0[\u00a0]: Copied! <pre>decomposed_circuit = device.decompose_circuit(circuit)\nSVGCircuit(decomposed_circuit)\n</pre> decomposed_circuit = device.decompose_circuit(circuit) SVGCircuit(decomposed_circuit) <p>Then we route the circuit based on Helmi's topology</p> In\u00a0[\u00a0]: Copied! <pre>routed_circuit, initial_mapping, final_mapping = device.route_circuit(decomposed_circuit)\nSVGCircuit(routed_circuit)\n</pre> routed_circuit, initial_mapping, final_mapping = device.route_circuit(decomposed_circuit) SVGCircuit(routed_circuit) <p>By printing the initial mapping we can see how the qubit names have beemn translated into the names of the qubits physically on Helmi and how the original qubit names were routed onto the device.</p> In\u00a0[\u00a0]: Copied! <pre>print(initial_mapping)\n</pre> print(initial_mapping) <p>This circuit can be executed on Helmi, but as an additional step we can simplify the circuit, using cirq-on-iqm's built in optimizers.</p> In\u00a0[\u00a0]: Copied! <pre>simplified_circuit = simplify_circuit(routed_circuit)\nSVGCircuit(simplified_circuit)\n</pre> simplified_circuit = simplify_circuit(routed_circuit) SVGCircuit(simplified_circuit) <p>The circuits can then be executed by calling <code>sampler.run</code>. Additionally, a folding function can be passed to process the sampled measurement results and convert the results into a format suitable for plotting for example.</p> In\u00a0[\u00a0]: Copied! <pre>def fold_func(x: np.ndarray) -&gt; str:\n    \"\"\"Fold the measured bit arrays into strings.\"\"\"\n    return ''.join(map(lambda x: chr(x + ord('0')), x))\n\nresult = sampler.run(simplified_circuit, repetitions=100)\n# print(result.measurements['m'])\nprint(result.histogram(key='m', fold_func=fold_func))\n</pre> def fold_func(x: np.ndarray) -&gt; str:     \"\"\"Fold the measured bit arrays into strings.\"\"\"     return ''.join(map(lambda x: chr(x + ord('0')), x))  result = sampler.run(simplified_circuit, repetitions=100) # print(result.measurements['m']) print(result.histogram(key='m', fold_func=fold_func)) <p>A histogram of the results can be plotted using <code>plot_state_histogram</code>.</p> In\u00a0[\u00a0]: Copied! <pre>def binary_labels(num_qubits):\n    return [bin(x)[2:].zfill(num_qubits) for x in range(2 ** num_qubits)]\n\n\ncirq.plot_state_histogram(result, plt.subplot(), tick_label=binary_labels(2))\n</pre> def binary_labels(num_qubits):     return [bin(x)[2:].zfill(num_qubits) for x in range(2 ** num_qubits)]   cirq.plot_state_histogram(result, plt.subplot(), tick_label=binary_labels(2)) <p>Additional metadata about the executed job can also be found.</p> In\u00a0[\u00a0]: Copied! <pre>print(\"Job ID: \", result.metadata.job_id)  # Retrieving the submitted job id\nprint(\"Calibration Set ID: \", result.metadata.calibration_set_id)  # Retrieving the current calibration set id.\n</pre> print(\"Job ID: \", result.metadata.job_id)  # Retrieving the submitted job id print(\"Calibration Set ID: \", result.metadata.calibration_set_id)  # Retrieving the current calibration set id.  In\u00a0[\u00a0]: Copied! <pre>result.\n</pre> result. In\u00a0[\u00a0]: Copied! <pre>circuit_list = []\n\nq1, q2 = cirq.NamedQubit('Alice'), cirq.NamedQubit('Bob')\ncircuit_1 = cirq.Circuit()\ncircuit_1.append(cirq.H(q1))\ncircuit_1.append(cirq.CNOT(q1, q2))\ncircuit_1.append(cirq.measure(q1, q2, key='m'))\n\nSVGCircuit(circuit_1)\n\ncircuit_2 = cirq.Circuit()\ncircuit_2.append(cirq.H(q1))\ncircuit_2.append(cirq.CNOT(q2, q1))\ncircuit_2.append(cirq.measure(q1, q2, key='m'))\n\nSVGCircuit(circuit_2)\n\nrouted_circuit_1, _, _ = device.route_circuit(device.decompose_circuit(circuit_1))\nrouted_circuit_2, _, _ = device.route_circuit(device.decompose_circuit(circuit_2))\n\ncircuit_list.append(routed_circuit_1)\ncircuit_list.append(routed_circuit_2)\n\nresults = sampler.run_iqm_batch(circuit_list, repetitions=10)\n\nfor result in results:\n     print(result.histogram(key=\"m\"))\n</pre> circuit_list = []  q1, q2 = cirq.NamedQubit('Alice'), cirq.NamedQubit('Bob') circuit_1 = cirq.Circuit() circuit_1.append(cirq.H(q1)) circuit_1.append(cirq.CNOT(q1, q2)) circuit_1.append(cirq.measure(q1, q2, key='m'))  SVGCircuit(circuit_1)  circuit_2 = cirq.Circuit() circuit_2.append(cirq.H(q1)) circuit_2.append(cirq.CNOT(q2, q1)) circuit_2.append(cirq.measure(q1, q2, key='m'))  SVGCircuit(circuit_2)  routed_circuit_1, _, _ = device.route_circuit(device.decompose_circuit(circuit_1)) routed_circuit_2, _, _ = device.route_circuit(device.decompose_circuit(circuit_2))  circuit_list.append(routed_circuit_1) circuit_list.append(routed_circuit_2)  results = sampler.run_iqm_batch(circuit_list, repetitions=10)  for result in results:      print(result.histogram(key=\"m\"))"},{"location":"examples/intro-to-helmi-cirq/#introduction-to-helmi-with-cirq","title":"Introduction to Helmi with Cirq\u00b6","text":"<p>Helmi is a 5 qubit Quantum Computer that is co-developed by VTT and IQM. It uses superconducting transmon qubits in a star shaped topology. Helmi's natives gates consist of the phased-rx and controlled-z gates. This architecture is called Adonis by IQM.</p> <p>In this tutorial running on Helmi is demonstrated using the Cirq framework. You can also run on Helmi using Qiskit with the qiskit-on-iqm adapter, and this is described in a separate notebook.</p> <p>Here is Helmi!</p>"},{"location":"examples/intro-to-helmi-cirq/#setup","title":"Setup\u00b6","text":"<p>This notebook uses the following requirements.</p> <pre>cirq-iqm==12.1\niqm-client==15.3\n</pre>"},{"location":"examples/intro-to-helmi-cirq/#using-helmi-with-cirq","title":"Using Helmi with Cirq\u00b6","text":"<p>First we import cirq-on-iqm which is needed to run on Helmi with cirq. You can read the user guide here.</p>"},{"location":"examples/intro-to-helmi-cirq/#constructing-and-executing-quantum-circuits","title":"Constructing and executing quantum circuits\u00b6","text":"<p>Circuits are constructed in Cirq by decomposing and routing them for the target topology. Additionally, you can run some simple optimization routines to get better peformance for your circuit.</p>"},{"location":"examples/intro-to-helmi-cirq/#batch-execution","title":"Batch execution\u00b6","text":"<p>Helmi also allows for batches of circuits to be submitted with 1 call to the quantum computer. A batch is simply a list of circuits. This is often faster than executing circuits individually, however, circuits will still be executed sequentially. On Helmi currently you can only place a maximum of 20 circuits in one batch. All circuits in a batch are executed with the same number of shots. The maximum number of shots per circuit is 100,000.</p> <p>With cirq this is implemented via the <code>run_iqm_batch</code> method of <code>sampler</code>.</p> <p>Batch submission of circuits allows parameterized circuits to be executed using the <code>cirq-resolve_parameters</code> function.</p>"},{"location":"examples/intro-to-helmi-cirq/#summary","title":"Summary\u00b6","text":"<p>In this notebook we have demonstrated how to connect and run circuits on Helmi with Cirq using the cirq-on-iqm adapter.</p>"},{"location":"examples/intro-to-helmi-cirq/#additional-reading","title":"Additional Reading\u00b6","text":"<ul> <li>Long-distance transmon coupler with CZ gate fidelity above 99.8%. Paper by IQM describing the superconducting technology behind Helmi.</li> <li>Helmi press release.</li> <li>cirq-on-iqm Github page.</li> <li>cirq-on-iqm documentation. We are running <code>11.13</code>.</li> <li>CSC documentation on Helmi.</li> </ul>"},{"location":"examples/intro-to-helmi-qiskit/","title":"Introduction to Helmi with Qiskit","text":"In\u00a0[\u00a0]: Copied! <pre>from iqm.qiskit_iqm import IQMProvider\nfrom iqm.qiskit_iqm.iqm_transpilation import optimize_single_qubit_gates\nimport networkx as nx\nfrom qiskit import QuantumCircuit, QuantumRegister, execute, transpile\nfrom qiskit.tools.monitor import job_monitor\nfrom qiskit.visualization import plot_histogram\n</pre> from iqm.qiskit_iqm import IQMProvider from iqm.qiskit_iqm.iqm_transpilation import optimize_single_qubit_gates import networkx as nx from qiskit import QuantumCircuit, QuantumRegister, execute, transpile from qiskit.tools.monitor import job_monitor from qiskit.visualization import plot_histogram <p>Then connection to the backend is simple! For this we point the <code>IQMProvider</code> at what is called the \"cocos URL\". The cocos url to access Helmi is provided below.</p> In\u00a0[\u00a0]: Copied! <pre>provider = IQMProvider(\"https://qc.vtt.fi/helmi/cocos\")\nbackend = provider.get_backend()\n</pre> provider = IQMProvider(\"https://qc.vtt.fi/helmi/cocos\") backend = provider.get_backend() <p>Now that we have the backend connected to Helmi, let's print out some information about Helmi!</p> In\u00a0[\u00a0]: Copied! <pre>print(f'Native operations: {backend.operation_names}')\nprint(f'Number of qubits: {backend.num_qubits}')\nprint(f'Coupling map: {backend.coupling_map}')\n</pre> print(f'Native operations: {backend.operation_names}') print(f'Number of qubits: {backend.num_qubits}') print(f'Coupling map: {backend.coupling_map}') <p>Visualising the topology with <code>networkx</code>:</p> In\u00a0[\u00a0]: Copied! <pre>G = nx.Graph()\nG.add_edges_from(backend.coupling_map)\nnode_labels = {node: f\"QB{node + 1}\" for node in G.nodes}\nnx.draw(G, labels=node_labels, node_color='skyblue', node_size=500, font_size=10)\n</pre> G = nx.Graph() G.add_edges_from(backend.coupling_map) node_labels = {node: f\"QB{node + 1}\" for node in G.nodes} nx.draw(G, labels=node_labels, node_color='skyblue', node_size=500, font_size=10) In\u00a0[\u00a0]: Copied! <pre>circuit = QuantumCircuit(2, name='Bell pair circuit')\ncircuit.h(0)\ncircuit.cx(0, 1)\ncircuit.measure_all()\ncircuit.draw(output='mpl')\n</pre> circuit = QuantumCircuit(2, name='Bell pair circuit') circuit.h(0) circuit.cx(0, 1) circuit.measure_all() circuit.draw(output='mpl') In\u00a0[\u00a0]: Copied! <pre>job = execute(circuit, backend, shots=100)\nprint(f\"Job ID: {job.job_id()}.\")\nprint(\"Tracking execution of job:\")\njob_monitor(job)\n</pre> job = execute(circuit, backend, shots=100) print(f\"Job ID: {job.job_id()}.\") print(\"Tracking execution of job:\") job_monitor(job) <p>You can also specify some backend arguments for running on Helmi. These are explained in the qiskit-on-iqm documentation.</p> In\u00a0[\u00a0]: Copied! <pre># job = execute(circuit, backend, shots=100, calibration_set_id=\"c5a5e2d1-100b-42d4-a4fd-a49edfb9d176\", circuit_duration_check=True, heralding_mode=\"zeros\")\n</pre> # job = execute(circuit, backend, shots=100, calibration_set_id=\"c5a5e2d1-100b-42d4-a4fd-a49edfb9d176\", circuit_duration_check=True, heralding_mode=\"zeros\") <p>After submitting, the job is now running. The status of the job can be queried using <code>job.status()</code>. Using the job id, you can retrieve previous jobs.</p> In\u00a0[\u00a0]: Copied! <pre>status = job.status()\nprint(status)\n#old_job = backend.retrieve_job(job_id)\n</pre> status = job.status() print(status) #old_job = backend.retrieve_job(job_id) <p>Instead of using the <code>execute</code> function you can also be explicit about your transpilation.</p> In\u00a0[\u00a0]: Copied! <pre>transpiled_circuit = transpile(circuit, backend=backend, layout_method='sabre', optimization_level=3)\ntranspiled_circuit.draw('mpl')\n</pre> transpiled_circuit = transpile(circuit, backend=backend, layout_method='sabre', optimization_level=3) transpiled_circuit.draw('mpl') <p>For more control, you can also specify the initial layout in both <code>transpile</code> and <code>execute</code>. For example, Helmi's topology only allows 2 qubit gates between the central and outer qubits. Therefore we can map the 2 qubit gate to QB3.  For this we make use of the <code>QuantumRegister</code>.</p> In\u00a0[\u00a0]: Copied! <pre>qreg = QuantumRegister(2, \"QB\")\ncircuit = QuantumCircuit(qreg, name='Bell pair circuit')\ncircuit.h(qreg[0])\ncircuit.cx(qreg[0], qreg[1])\ncircuit.measure_all()\n\n\n# Qubit numbers start at 0 index whereas the qubit names start at 1 index. \nqubit_mapping = {\n    qreg[0]: 1,  # Map the first qubit to QB1\n    qreg[1]: 2,  # Map the second qubit to QB3\n    }\n\n\njob = execute(circuit, backend, shots=100, initial_layout=qubit_mapping)\n</pre> qreg = QuantumRegister(2, \"QB\") circuit = QuantumCircuit(qreg, name='Bell pair circuit') circuit.h(qreg[0]) circuit.cx(qreg[0], qreg[1]) circuit.measure_all()   # Qubit numbers start at 0 index whereas the qubit names start at 1 index.  qubit_mapping = {     qreg[0]: 1,  # Map the first qubit to QB1     qreg[1]: 2,  # Map the second qubit to QB3     }   job = execute(circuit, backend, shots=100, initial_layout=qubit_mapping) <p>Qiskit refers to qubits using integer indices, whereas IQM uses strings. The backend class provides utility methods for mapping them to one another. Let's see on which physical qubits the logical circuit qubits were mapped.</p> In\u00a0[\u00a0]: Copied! <pre>mapping = {}\nfor qubit in circuit.qubits:\n    index = circuit.find_bit(qubit).index\n    mapping[index] = backend.index_to_qubit_name(index)\n \nprint(mapping)\n</pre> mapping = {} for qubit in circuit.qubits:     index = circuit.find_bit(qubit).index     mapping[index] = backend.index_to_qubit_name(index)   print(mapping) In\u00a0[\u00a0]: Copied! <pre>circuit_optimized = optimize_single_qubit_gates(transpiled_circuit)\ncircuit_optimized.draw('mpl')\n</pre> circuit_optimized = optimize_single_qubit_gates(transpiled_circuit) circuit_optimized.draw('mpl') In\u00a0[\u00a0]: Copied! <pre>result = job.result()\nprint(result.job_id)  # The job id can be queried from the result\nprint(result.get_counts())\n# print(result.get_memory())\n\nplot_histogram(result.get_counts())\n</pre> result = job.result() print(result.job_id)  # The job id can be queried from the result print(result.get_counts()) # print(result.get_memory())  plot_histogram(result.get_counts()) <p>Additional metadata about the executed job can also be found.</p> In\u00a0[\u00a0]: Copied! <pre>exp_result = result._get_experiment(circuit)\nprint(\"Job ID: \", job.job_id())  # Retrieving the submitted job id\nprint(result.request.circuits)  # Retrieving the circuit request sent\nprint(\"Calibration Set ID: \", exp_result.calibration_set_id)  # Retrieving the current calibration set id. \nprint(result.request.qubit_mapping)  # Retrieving the qubit mapping\nprint(result.request.shots)  # Retrieving the number of requested shots. \nprint(exp_result.header)\n</pre> exp_result = result._get_experiment(circuit) print(\"Job ID: \", job.job_id())  # Retrieving the submitted job id print(result.request.circuits)  # Retrieving the circuit request sent print(\"Calibration Set ID: \", exp_result.calibration_set_id)  # Retrieving the current calibration set id.  print(result.request.qubit_mapping)  # Retrieving the qubit mapping print(result.request.shots)  # Retrieving the number of requested shots.  print(exp_result.header) In\u00a0[\u00a0]: Copied! <pre>from iqm.qiskit_iqm import IQMFakeAdonis\nfake_backend = IQMFakeAdonis()\njob = execute(circuit, fake_backend, shots=1000)\nprint(job.result().get_counts())\nplot_histogram(job.result().get_counts())\n</pre> from iqm.qiskit_iqm import IQMFakeAdonis fake_backend = IQMFakeAdonis() job = execute(circuit, fake_backend, shots=1000) print(job.result().get_counts()) plot_histogram(job.result().get_counts()) <p>The error profile of the noise can be queried and customised by the user following the qiskit-iqm user guide.</p> In\u00a0[\u00a0]: Copied! <pre>print(fake_backend.error_profile)\n</pre> print(fake_backend.error_profile) In\u00a0[\u00a0]: Copied! <pre>error_profile = fake_backend.error_profile\nerror_profile.t1s['QB1'] = 38940.0  # in ns 3.8940\nerror_profile.t1s['QB2'] = 25127.0  # in ns\nerror_profile.t1s['QB3'] = 43322.0  # in ns\nerror_profile.t1s['QB4'] = 38223.0  # in ns\nerror_profile.t1s['QB5'] = 37365.0  # in ns\n\nerror_profile.t2s['QB1'] = 24785.0  # in ns\nerror_profile.t2s['QB2'] = 20751.0  # in ns\nerror_profile.t2s['QB3'] = 10050.0  # in ns\nerror_profile.t2s['QB4'] = 14391.0  # in ns\nerror_profile.t2s['QB5'] = 29012.0  # in ns\n\nerror_profile.single_qubit_gate_depolarizing_error_parameters['phased_rx']['QB1'] = 0.0043 \nerror_profile.single_qubit_gate_depolarizing_error_parameters['phased_rx']['QB2'] = 0.0018 \nerror_profile.single_qubit_gate_depolarizing_error_parameters['phased_rx']['QB3'] = 0.0022 \nerror_profile.single_qubit_gate_depolarizing_error_parameters['phased_rx']['QB4'] = 0.0037 \nerror_profile.single_qubit_gate_depolarizing_error_parameters['phased_rx']['QB5'] = 0.0024\n\nerror_profile.two_qubit_gate_depolarizing_error_parameters['cz'][('QB1', 'QB3')] = 0.018\nerror_profile.two_qubit_gate_depolarizing_error_parameters['cz'][('QB2', 'QB3')] = 0.033\nerror_profile.two_qubit_gate_depolarizing_error_parameters['cz'][('QB3', 'QB4')] = 0.030\nerror_profile.two_qubit_gate_depolarizing_error_parameters['cz'][('QB3', 'QB5')] = 0.017\n\nerror_profile.single_qubit_gate_durations['phased_rx'] = 120  # in ns\nerror_profile.two_qubit_gate_durations['cz'] = 120  # in ns\n\nerror_profile.readout_errors['QB1']['0'] = 0.03375\nerror_profile.readout_errors['QB1']['1'] = 0.03865\nerror_profile.readout_errors['QB2']['0'] = 0.032\nerror_profile.readout_errors['QB2']['1'] = 0.0520\nerror_profile.readout_errors['QB3']['0'] = 0.0365\nerror_profile.readout_errors['QB3']['1'] = 0.05885\nerror_profile.readout_errors['QB4']['0'] = 0.03735\nerror_profile.readout_errors['QB4']['1'] = 0.06225 \nerror_profile.readout_errors['QB5']['0'] = 0.04375\nerror_profile.readout_errors['QB5']['1'] = 0.05689\n\nerror_profile.name = 'fake_helmi'\n\n\nhelmi_fake_backend = fake_backend.copy_with_error_profile(error_profile)\n</pre> error_profile = fake_backend.error_profile error_profile.t1s['QB1'] = 38940.0  # in ns 3.8940 error_profile.t1s['QB2'] = 25127.0  # in ns error_profile.t1s['QB3'] = 43322.0  # in ns error_profile.t1s['QB4'] = 38223.0  # in ns error_profile.t1s['QB5'] = 37365.0  # in ns  error_profile.t2s['QB1'] = 24785.0  # in ns error_profile.t2s['QB2'] = 20751.0  # in ns error_profile.t2s['QB3'] = 10050.0  # in ns error_profile.t2s['QB4'] = 14391.0  # in ns error_profile.t2s['QB5'] = 29012.0  # in ns  error_profile.single_qubit_gate_depolarizing_error_parameters['phased_rx']['QB1'] = 0.0043  error_profile.single_qubit_gate_depolarizing_error_parameters['phased_rx']['QB2'] = 0.0018  error_profile.single_qubit_gate_depolarizing_error_parameters['phased_rx']['QB3'] = 0.0022  error_profile.single_qubit_gate_depolarizing_error_parameters['phased_rx']['QB4'] = 0.0037  error_profile.single_qubit_gate_depolarizing_error_parameters['phased_rx']['QB5'] = 0.0024  error_profile.two_qubit_gate_depolarizing_error_parameters['cz'][('QB1', 'QB3')] = 0.018 error_profile.two_qubit_gate_depolarizing_error_parameters['cz'][('QB2', 'QB3')] = 0.033 error_profile.two_qubit_gate_depolarizing_error_parameters['cz'][('QB3', 'QB4')] = 0.030 error_profile.two_qubit_gate_depolarizing_error_parameters['cz'][('QB3', 'QB5')] = 0.017  error_profile.single_qubit_gate_durations['phased_rx'] = 120  # in ns error_profile.two_qubit_gate_durations['cz'] = 120  # in ns  error_profile.readout_errors['QB1']['0'] = 0.03375 error_profile.readout_errors['QB1']['1'] = 0.03865 error_profile.readout_errors['QB2']['0'] = 0.032 error_profile.readout_errors['QB2']['1'] = 0.0520 error_profile.readout_errors['QB3']['0'] = 0.0365 error_profile.readout_errors['QB3']['1'] = 0.05885 error_profile.readout_errors['QB4']['0'] = 0.03735 error_profile.readout_errors['QB4']['1'] = 0.06225  error_profile.readout_errors['QB5']['0'] = 0.04375 error_profile.readout_errors['QB5']['1'] = 0.05689  error_profile.name = 'fake_helmi'   helmi_fake_backend = fake_backend.copy_with_error_profile(error_profile) In\u00a0[\u00a0]: Copied! <pre>job = execute(circuit, helmi_fake_backend, shots=1000)\nprint(job.result().get_counts())\nplot_histogram(job.result().get_counts())\n</pre> job = execute(circuit, helmi_fake_backend, shots=1000) print(job.result().get_counts()) plot_histogram(job.result().get_counts()) In\u00a0[\u00a0]: Copied! <pre>circuits_list = []\n\ncircuit_1 = QuantumCircuit(2, name='Bell pair circuit')\ncircuit_1.h(0)\ncircuit_1.cx(0, 1)\ncircuit_1.measure_all()\ncircuits_list.append(circuit_1)\n\ncircuit_1.draw(output='mpl')\n</pre> circuits_list = []  circuit_1 = QuantumCircuit(2, name='Bell pair circuit') circuit_1.h(0) circuit_1.cx(0, 1) circuit_1.measure_all() circuits_list.append(circuit_1)  circuit_1.draw(output='mpl') In\u00a0[\u00a0]: Copied! <pre>circuit_2 = QuantumCircuit(2, name='Reverse Bell pair circuit')\ncircuit_2.h(1)\ncircuit_2.cx(1, 0)\ncircuit_2.measure_all()\ncircuits_list.append(circuit_2)\n\ncircuit_2.draw(output='mpl')\n</pre> circuit_2 = QuantumCircuit(2, name='Reverse Bell pair circuit') circuit_2.h(1) circuit_2.cx(1, 0) circuit_2.measure_all() circuits_list.append(circuit_2)  circuit_2.draw(output='mpl') In\u00a0[\u00a0]: Copied! <pre># Execute and monitor job\njob = execute(circuits_list, backend, shots=10, optimization_level=3, initial_layout=[0,2])\nprint(\"Tracking execution of job:\")\njob_monitor(job)\n</pre> # Execute and monitor job job = execute(circuits_list, backend, shots=10, optimization_level=3, initial_layout=[0,2]) print(\"Tracking execution of job:\") job_monitor(job) In\u00a0[\u00a0]: Copied! <pre># Get results\nresult = job.result()\n\n# Plot histograms\nplot_histogram(result.get_counts(), legend=['Circuit 1', 'Circuit 2'])\n</pre> # Get results result = job.result()  # Plot histograms plot_histogram(result.get_counts(), legend=['Circuit 1', 'Circuit 2']) In\u00a0[\u00a0]: Copied! <pre>import pennylane as qml\n\nprovider = IQMProvider(\"https://helmi.vtt.fi/cocos\")\nbackend = provider.get_backend()\n\n\ndev = qml.device('qiskit.remote', wires=5, backend=backend, shots=10)\n\nprint(dev.capabilities())\n\n@qml.qnode(dev, interface=\"autograd\")\ndef circuit(params):\n    qml.RX(params[0], wires=0)\n    qml.RY(params[1], wires=0)\n    return qml.expval(qml.PauliZ(0))\n\n\nprint(circuit([0.54, 0.12]))\n</pre> import pennylane as qml  provider = IQMProvider(\"https://helmi.vtt.fi/cocos\") backend = provider.get_backend()   dev = qml.device('qiskit.remote', wires=5, backend=backend, shots=10)  print(dev.capabilities())  @qml.qnode(dev, interface=\"autograd\") def circuit(params):     qml.RX(params[0], wires=0)     qml.RY(params[1], wires=0)     return qml.expval(qml.PauliZ(0))   print(circuit([0.54, 0.12]))"},{"location":"examples/intro-to-helmi-qiskit/#introduction-to-helmi-with-qiskit","title":"Introduction to Helmi with Qiskit\u00b6","text":"<p>Helmi is a 5 qubit Quantum Computer that is co-developed by VTT and IQM. It uses superconducting transmon qubits in a star shaped topology. Helmi's natives gates consist of the phased-rx and controlled-z gates. This architecture is called Adonis by IQM.</p> <p>In this tutorial running on Helmi is demonstrated using the Qiskit framework. You can also run on Helmi using Cirq with cirq-on-iqm adapter, and this is described in a separate notebook.</p> <p>Here is Helmi!</p>"},{"location":"examples/intro-to-helmi-qiskit/#setup","title":"Setup\u00b6","text":"<p>This notebook uses the following requirements.</p> <pre>qiskit-iqm==11.10\niqm-client==15.3\nqiskit[visualization]\npylatexenc\nPennyLane-qiskit @ git+https://github.com/NordIQuEst/pennylane-qiskit@support-num-qubits\n</pre>"},{"location":"examples/intro-to-helmi-qiskit/#using-helmi-with-qiskit","title":"Using Helmi with Qiskit\u00b6","text":"<p>First we import qiskit-on-iqm which is needed to run on Helmi with qiskit. You can read the user guide here.</p>"},{"location":"examples/intro-to-helmi-qiskit/#constructing-and-executing-quantum-circuits","title":"Constructing and executing quantum circuits\u00b6","text":"<p>Circuits are constructed and submitted to Helmi using the same methods as with IBM machines. First we construct a Bell pair circuit between 2 qubits. The circuit is then executed on the backend using the <code>execute</code> function.</p>"},{"location":"examples/intro-to-helmi-qiskit/#executing-the-circuit-on-helmi","title":"Executing the circuit on Helmi\u00b6","text":"<p>When submitting a job to Helmi a unique identifier for your job is returned. This can be used to gather additional information about the circuit you just submitted and the results. You should save your job ids!</p>"},{"location":"examples/intro-to-helmi-qiskit/#explicit-transpilation","title":"Explicit Transpilation\u00b6","text":""},{"location":"examples/intro-to-helmi-qiskit/#optimizing-circuits-for-helmi","title":"Optimizing circuits for Helmi\u00b6","text":"<p>Qiskit on IQM provides the option to optimize your transpiled quantum circuits for running on Helmi. Currently the optimization uses Qiskit's transpiler passes to reduce the number of single qubit gates in the quantum circuit, thus reducing the total circuit depth. Further information can be found in the IQM qiskit documentation.</p> <p>Here we optimize the previous instance of <code>transpiled_circuit</code> as the <code>optimize_single_qubit_gates</code> expected a transpiled circuit as an argument.</p>"},{"location":"examples/intro-to-helmi-qiskit/#results","title":"Results\u00b6","text":"<p>Results can be printed once the job has completed. If results are queried before the job has completed then an error will be returned.</p>"},{"location":"examples/intro-to-helmi-qiskit/#simulating-circuits-locally-with-noise","title":"Simulating circuits locally with noise\u00b6","text":"<p>Qiskit on IQM provides an <code>IQMFakeBackend</code> with <code>IQMFakeAdonis</code> for simulating Helmi.</p>"},{"location":"examples/intro-to-helmi-qiskit/#batch-execution","title":"Batch execution\u00b6","text":"<p>Helmi also allows for batches of circuits to be submitted with 1 call to the quantum computer. A batch is simply a list of <code>QuantumCircuits</code>. This is often faster than executing circuits individually, however, circuits will still be executed sequentially. On Helmi currently you can only place a maximum of 20 circuits in one batch. All circuits in a batch are executed with the same number of shots. The maximum number of shots per circuit is 100,000.</p> <p>All circuits in a batch must measure the same qubits. Adding the <code>initial_layout</code> argument when submitting ensures that you always measure the same qubits.</p> <p>Batch submission of circuits allows parameterized circuits to be executed using the <code>qiskit.circuit.Parameter</code> class.</p>"},{"location":"examples/intro-to-helmi-qiskit/#pennylane-qiskit","title":"Pennylane Qiskit\u00b6","text":"<p>You can also run Pennylane code on Helmi with the PennyLane-Qiskit Plugin. The <code>IQMBackend</code> object uses <code>BackendV2</code> currently which Pennylane-Qiskit does not support, therefore we use a forked-version that fixes this.</p>"},{"location":"examples/intro-to-helmi-qiskit/#summary","title":"Summary\u00b6","text":"<p>In this notebook we have demonstrated how to connect and run circuits on Helmi with Qiskit, qiskit-on-iqm and the PennyLane-Qiskit plugin.</p>"},{"location":"examples/intro-to-helmi-qiskit/#additional-reading","title":"Additional Reading\u00b6","text":"<ul> <li>Long-distance transmon coupler with CZ gate fidelity above 99.8%. Paper by IQM describing the superconducting technology behind Helmi.</li> <li>Helmi press release.</li> <li>qiskit-on-iqm Github page.</li> <li>qiskit-on-iqm documentation. We are running <code>11.10</code>.</li> <li>CSC documentation on Helmi.</li> <li>Pennylane-Qiskit documentation.</li> </ul>"}]}