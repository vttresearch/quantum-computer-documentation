{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the VTT Q5 documentation","text":"<p>This website contains the technical documentation about VTT's Quantum Computers and how to access them. Currently we provide access to VTT Q5, a 5 qubit superconducting quantum computer, also named \"Helmi\". Access to Helmi is currently provided through the EuroHPC Supercomputer LUMI, operated by CSC.</p> <ul> <li>Companies can get access to Helmi here.</li> <li>Academic researchers can get access to Helmi by following the instructions here.</li> </ul> <p>Once a My CSC project has been created for you, the next steps can be found on the Accessing LUMI page.</p>"},{"location":"#additional-links","title":"Additional links","text":"<ul> <li>CSC Documentation</li> <li>LUMI Documentation</li> <li>Finland's first quantum computer opened for companies Press release</li> </ul>"},{"location":"acknowledgement/","title":"Acknowledgement","text":""},{"location":"acknowledgement/#how-to-cite-vtt-q5-helmi-in-an-academic-paper","title":"How to cite VTT Q5 \"Helmi\" in an academic paper?","text":"<p>When publishing the results that utilise Helmi, users should acknowledge the use of Helmi and VTT, preferably in the format: \"These [results] have been acquired by VTT's quantum computer Helmi.\". Users can use either \"Helmi\" or \"VTT Q5\" when referring to the quantum computer.</p> <p>Users can cite this webpage when referring to technical details of Helmi. For example</p> <p>VTT Quantum Computer Documentation (2024)</p>"},{"location":"acknowledgement/#how-to-reference-helmi-in-publications-or-presentations","title":"How to reference Helmi in publications or presentations","text":"<p>When referencing Helmi in publications or presentations you can refer to this technical documentation. Images contained in this documentation are licensed under creative commons CC BY 4.0.</p> <p>Additionally, you can refer to Helmi with the following links:</p> <ul> <li>https://www.vttresearch.com/en/ourservices/quantum-computing</li> <li>https://www.vttresearch.com/en/news-and-ideas/finland-opens-quantum-computer-research-purposes-fusion-quantum-computing-and</li> </ul>"},{"location":"calibration/","title":"Calibration","text":"<p>Helmi is continuously calibrated to ensure functionality. The calibration process involves a series of experiments, aimed at fine-tuning the parameters, necessary for controlling and measuring the qubits. In addition to calibration, we run benchmarks to obtain the figures of merit reflecting the current state of the quantum computer.</p> <p>Note</p> <p>Calibration and benchmarking experiments are interleaved with regular user jobs in Helmi's job queue, as detailed in the Running on Helmi section. The calibration might therefore slightly increase the waiting time in the queue of regular user jobs.</p>"},{"location":"calibration/#calibration-sequences","title":"Calibration sequences","text":"<p>To minimize the impact of calibration on user operations, we execute shorter calibration sequences during the day and a longer calibration run throughout the night.</p> <p>Short calibration:</p> <ul> <li>Every 2 hours from 11 am to 11 pm</li> <li>Adjusts qubit drive frequency, drive amplitude and readout threshold</li> <li>Measures \\(T_1\\), \\(T_2\\), \\(T_2^*\\) and readout accuracy</li> </ul> <p>Extended calibration:</p> <ul> <li>Every day at 4 am</li> <li>Adjusts qubit drive frequency, amplitude fine-tuning and readout threshold</li> <li>Measures \\(T_1\\), \\(T_2\\), \\(T_2^*\\), readout accuracy, single- and two-qubit gate fidelities</li> </ul> <p>A calibration sequence produces what is called a <code>calibration_set</code>. This is a set of device parameters, which the quantum computer is currently using to execute quantum circuits. It is identified via a <code>calibration_set_id</code>, a unique identifier for the specific <code>calibration_set</code>. Usually, when submitting quantum circuits, the most up-to-date calibration set is used, however, it is possible to use a specific <code>calibration_set_id</code>. This can be useful for testing the degradation of the performance of our quantum computers.</p>"},{"location":"calibration/#quality-metrics-set","title":"Quality metrics set","text":"<p>The benchmarks results are summarized in the quality metric set representing the figures of merit and reflecting the latest state of the quantum computer. The calibration metrics can be fetched from Helmi's API by sending HTTP <code>GET</code> requests to <code>/calibration/metrics/latest</code>. An example script is provided here. Each quality metrics set is identified via a unique ID, with a new ID created after each calibration. Note, that not all metrics are updated after each calibration run. We recommend to save the current calibration set ID together with the job ID to facilitate debugging and analysis. Also note that it can happen that there is a delay of up to 10 minutes between calibrating the device and benchmarking the quality metrics set, causing there to be some delay in presenting the quality metrics data.</p> <p>The metrics contained in the quality metrics set are summarized below:</p> Metric Description \\(T_1\\) time (s) The \\(T_1\\) time is called the longitudinal relaxation rate and describes how quickly the excited state of the qubit returns to its ground state. \\(T_2\\) time (s) The \\(T_2\\) time is called the transverse relaxation rate and describes loss of coherence of a superposition state. \\(T_2\\)-echo time (s) The \\(T_2\\)-echo time describes the loss of coherence of the superposition state of the qubit. It is more precise than the \\(T_2\\) Time as it is less susceptible to low-frequency noise. Single-shot readout fidelity Measures the average accuracy of distinguishing qubit states. The experiment prepares for 50% of the shots the qubit in the ground state \\(| 0\\rangle\\) and for the other 50% in the excited state \\(| 1\\rangle\\). Single-shot readout 10 error The error in labelling the qubit state as \\(| 0\\rangle\\) when it was prepared in state \\(| 1\\rangle\\) Single-shot readout 01 error The error in labelling the qubit state as \\(| 1\\rangle\\) when it was prepared in state \\(| 0\\rangle\\) 1QB average gate fidelity Average 1QB gate fidelity estimated with randomized benchmarking. 2QB average gate fidelity The average 2QB gate fidelity estimated with randomized benchmarking. CZ gate fidelity The average CZ gate fidelity estimated with interleaved randomized benchmarking. It is usually higher than the average 2QB gate fidelity as a random 2QB Clifford transpiles on average to 8 1QB gates and 1.5 CZ gates. <p>These metrics provide critical insights into the operational efficiency, error rates, and coherence properties of Helmi. Understanding these figures of merit allows a user to make informed decisions on transpilation strategies and qubit selection, optimizing for circuit depth or fidelity.</p>"},{"location":"calibration/#example-response","title":"Example response","text":"<p>Here is an example response from Helmi's API for the calibration and quality metrics set</p> <pre><code>{\n  \"calibration_set_id\": \"03436204-3588-4567-95ec-5a61acfd227d\",\n  \"quality_metric_set_id\": \"ec1298a0-43ce-43f2-b6d1-10c1fe750786\",\n  \"metrics\": {\n    \"QB1.fidelity_1qb_gates_averaged\": {\n      \"value\": \"0.9971526901996984\",\n      \"unit\": \"\",\n      \"uncertainty\": \"5.622242981254397e-05\",\n      \"timestamp\": \"2024-03-20T05:05:08.109836\"\n    },\n    \"TC-3-5.cz_gate_fidelity\": {\n      \"value\": \"0.9848983187049354\",\n      \"unit\": \"\",\n      \"uncertainty\": \"0.002603321013490276\",\n      \"timestamp\": \"2024-03-20T05:05:08.109836\"\n    }\n  }\n}\n</code></pre>"},{"location":"faq/","title":"FAQ","text":"<p>Q: Does the name \"Helmi\" have a meaning?</p> <p>Helmi is the Finnish word for pearl.</p> <p>Q: Does Helmi provide pulse-level access?</p> <p>Currently, we only provide circuit-level access.</p> <p>Q: Is there any optimization applied during gate-to-pulse compilation?</p> <p>No circuit optimization is performed after the circuit has been submitted in serialized form with the IQM client. The gate-to-pulse compiler replaces each gate by the corresponding pulse and submits the pulses to the backend for execution.</p> <p>Q: Is heralding enabled on Helmi?</p> <p>Heralding is an optional feature that allows for post-selection of shots, to filter out runs where one or more qubits were not in the ground state at the beginning of the circuit execution. The feature is currently unavailable on Helmi.</p> <p>Q: What is the time-to-execution after a job has been scheduled on Helmi?</p> <p>An overhead of 10 seconds can be expected. The largest overhead is introduced by compiling the pulses to instructions for the control electronics and the upload to the instruments.</p> <p>Q: Does the number of shots affect the calibration of Helmi?</p> <p>No, a large number of shots will not cause thermal excitations of the qubits.</p> <p>Q: Can Pennylane be used on Helmi?</p> <p>Yes, Pennylane can be used on Helmi through a fork of the Pennylane-Qiskit package. This is demonstrated in the Introduction to Helmi with Qiskit example.</p>"},{"location":"helmi/","title":"VTT Q5 \"Helmi\"","text":"<p>VTT Q5 is a 5 qubit superconducting quantum computer computer co-developed and built by IQM and VTT. It uses flux-tunable qubits and couplers which are described in this paper<sup>1</sup>.</p> <p>Helmi's qubits are arranged in a star-shaped topology, meaning that the central qubit, QB3, is connected to all of the outer qubits, QB1, QB2, QB4. Two-qubit gates can be applied only between the central qubit and the outer qubits.</p> <p> VTT Q5 star-shaped topology</p> <p>The qubits are pairwise connected with tunable couplers.</p>"},{"location":"helmi/#native-gate-set","title":"Native-gate set","text":"<p>To run arbitrary quantum circuits, a QPU needs to implement a universal gate set. Helmi implements the following gates natively:</p> <ul> <li>Single-qubit gates: Phased-\\(RX\\) gate (PRX)</li> <li>Two-qubit gate: Controlled-\\(Z\\) gate (CZ)</li> </ul> <p>Measurements are natively implemented as single-qubit measurements in the \\(Z\\) basis.</p>"},{"location":"helmi/#characteristics","title":"Characteristics","text":"<p>The values below are averaged values. Actual values might differ from day-to-day.</p> QB1 QB2 QB3 QB4 QB5 Drive Frequencies [GHz] 4.4 3.9 4.2 4.4 4.4 Readout Frequencies [GHz] 5.3 5.0 6.2 5.9 5.6 T1 time [\u00b5s] 35.5 25.7 40.2 41.3 36.0 T2 time [\u00b5s] 19.2 17.7 9.12 19.1 22.2 T2 echo time [\u00b5s] 45.2 33.1 26.5 47.7 35.0 Single-Qubit Gate Fidelities<sup>2</sup> [%] 99.4 99.7 99.7 99.6 99.7 Readout Fidelities [%] 96 95 95 95 95 <p>The coupler characteristics are given below. TC refers to tunable coupler.</p> TC-3-1 TC-3-2 TC-3-4 TC-3-5 Two-qubit Gate Fidelities<sup>3</sup> [%] 96.4 95.9 94.6 97.5 <p>The PRX gate length and the CZ gate length is 120 [ns] respectively.</p> <ol> <li> <p>Long-Distance Transmon Coupler with cz-Gate Fidelity above 99.8%, Marxer et al. \u21a9</p> </li> <li> <p>Calculated via randomized benchmarking\u00a0\u21a9</p> </li> <li> <p>CZ gate fidelity calculated via interleaved randomized benchmarking\u00a0\u21a9</p> </li> </ol>"},{"location":"limitations/","title":"Limitations","text":"<p>There are a number of limitations on Helmi that need to be taken into account when writing quantum circuits.</p> <p>Queue length</p> <p>To ensure manageable wait times, the job queue can accommodate up to 100 sequential jobs. Jobs when the queue reached its limit will be denied, triggering the following error message from the IQM client:</p> <pre><code>ClientAuthenticationError: Authentication failed: {\"detail\":\"Job rejected: Too many circuits in queue\"}\n</code></pre> <p>Batch size</p> <p>On our Helmi system, quantum circuits within a batch are processed sequentially. To prevent extensive queue occupation by large batches, we have set a maximum limit of 20 circuits per batch. Jobs submitting batches with more than 20 circuits will be rejected and the IQM client will return the following error</p> <pre><code>ClientAuthenticationError: Authentication failed: {\"detail\":\"Too many circuits X in batch (max: 20)\"}\n</code></pre> <p>Here, 'X' denotes the actual number of circuits attempted to be included in the batch.</p> <p>Number of shots</p> <p>The execution time for a quantum circuit scales with the number of shots. To avoid disproportionately long job durations, we impose a threshold of 100,000 shots per circuit. Should your experiment require more shots, we recommend dividing it into multiple separate jobs. For cases where this shot limit proves inadequate, please do not hesitate to reach out to our support.</p>"},{"location":"lumi/","title":"Accessing LUMI","text":"<p>Before accessing LUMI you need to be added to a project in My CSC with your CSC account. Access to LUMI is currently only through the command line interface, with access provided over SSH. Users using LUMI should have some experience with the Linux command line and familiarity with HPC systems. To log on to LUMI, you will first need to add your ssh key on your My CSC profile section.</p> <p>The LUMI documentation offers a guide for creating SSH keypairs from which you should follow the instructions labeled \"With a Finnish allocation\".</p> <p>Note</p> <p>It might take a couple of hours until your public key is distributed to all LUMI nodes.</p> <p>Warning</p> <p>The private key should never be shared with anyone. It should only be stored on your local computer. Otherwise, anyone can steal the SSH key and impersonate you.</p> <p>Once your public SSH key is available on all login nodes, you can access LUMI using</p> <pre><code>ssh -i &lt;path-to-private-key&gt; &lt;username&gt;@lumi.csc.fi\n</code></pre> <p>The LUMI documentation provides further information on how to connect to LUMI. For an introduction to LUMI, its architecture, modules and software stack, take a look at the LUMI training materials.</p>"},{"location":"lumi/#storage","title":"Storage","text":"<p>LUMI uses a Linux based parallel filesystem, utilising lustre. Access to different parts of the file system are based on the projects you are associated with. LUMI's storage areas and their intended use cases are described here.</p>"},{"location":"lumi/#configuring-the-environment","title":"Configuring the environment","text":"<p>To run quantum circuits on LUMI we need to load certain Python modules. Dependencies are managed via <code>modules</code>, which can be loaded.</p> <p>To load the required modules, after connecting to LUMI, run the following lines in your terminal</p> <pre><code>module use /appl/local/quantum/modulefiles\nmodule load helmi_qiskit  # or helmi_cirq\n</code></pre> <p>This commands can also be added to your <code>.bashrc</code> to save repetition. In case you are curious, you can explore other available modules via <code>module avail</code>.</p>"},{"location":"lumi/#using-a-custom-python-environment","title":"Using a custom Python environment","text":"<p>Loading <code>helmi_qiskit</code> or <code>helmi_cirq</code> on LUMI comes with a preconfigured Python environment for submitting jobs to Helmi. This environment can be replicated by users, by following the LUMI documentation on installing python packages. To access Helmi you will still need to load the <code>helmi_standard</code> module.</p> <p> Package Version iqm-client  &gt;=15.2 &lt; 16.0 qiskit-iqm &gt;=11.10 &lt; 12.0 cirq-iqm &gt;=12.2 &lt; 13.0 <p></p> <p>Newer versions of the above Python packages can be installed and may work with Helmi, however these are currently unsupported and may lead to errors.</p> <p>As an alternative to the above, Python packages can be installed on top of <code>helmi_qiskit</code> or <code>helmi_cirq</code> into the Python user install directory by specifying <code>python -m pip install --user whatsapp</code>. This, however, may lead to increased dependency conflicts.</p>"},{"location":"lumi/#submitting-jobs","title":"Submitting jobs","text":"<p>Once you have access to LUMI and have configured your environment you can learn how to run jobs on Helmi with the Running on Helmi.</p>"},{"location":"running/","title":"Running on Helmi","text":"<p>To run interactive jobs on LUMI the <code>srun</code> command can be used</p> <pre><code>srun --account=project_&lt;id&gt; -t 0:02:00 -c 1 -n 1 --partition q_industry python qiskit_flip.py\n</code></pre> <p>The command takes a number of arguments</p> <ul> <li><code>--account</code>: Unix group string which can be found in your MyCSC project.</li> <li><code>-t</code>: Sets a limit on total run time of job allocation. Upper bound is 15 minutes.</li> <li><code>-c</code>: Requests that \\(n\\) CPUs be allocated per process.</li> <li><code>-n</code>: Number of tasks to run in parallel. If greater than 1, a job may be assigned to multiple nodes.</li> <li><code>--partition</code>: The partition to run on. Should be <code>q_industry</code>.</li> <li><code>cmd</code>: The command to run. In this case <code>python qiskit_flip.py</code></li> </ul> <p>Note, that the <code>srun</code> command is blocking, which means that you'll have to wait until your program terminates before <code>srun</code> returns and you can enter your next command. Alternatively you can also load a shell on the compute node to provide more flexibility. This can be done with the following command:</p> <pre><code>srun --account=project_&lt;id&gt; -t 0:15:00 -c 1 -n 1 --partition q_industry --pty bash\n</code></pre> <p>This command loads a bash shell on the compute node with access to Helmi. After getting the shell, you may need to load your modules again.</p> <p>Note</p> <p>The LUMI Web-interface is now available at www.lumi.csc.fi. You can run jupyter-notebooks through this web interface. See the section below for further details.</p> <p>To run longer experiments, it is advisable to use <code>sbatch</code> which executes batch jobs on LUMI.</p> <pre><code>#!/bin/bash\n\n#SBATCH --job-name=helmijob     # Job name\n#SBATCH --account=project_&lt;id&gt;  # Project for billing\n#SBATCH --partition=q_industry  # Partition (queue) name\n#SBATCH --ntasks=1              # One task (process)\n#SBATCH --cpus-per-task=1       # Number of cores (threads)\n#SBATCH --time=00:15:00         # Run time (hh:mm:ss)\n\nmodule use /appl/local/quantum/modulefiles\n\n# uncomment correct line:\n# module load helmi_qiskit\n# or\n# module load helmi_cirq\n\npython your_python_script.py\n</code></pre>"},{"location":"running/#job-queues","title":"Job queues","text":"<p>Running on Helmi through LUMI involves using two queues. The first one is the SLURM queue on LUMI. Users interact with SLURM using the <code>srun</code> or <code>sbatch</code> commands for job submission and can fetch details about the queue state using <code>squeue -p &lt;partition&gt;</code>. The state of the partition can be viewed with <code>sinfo -p &lt;partition&gt;</code>.</p> <p>Jobs on LUMI have the following limitations</p> <ul> <li>Maximum duration for any job is 15 minutes</li> <li>Maximum of 32 cores</li> </ul> <p>After your job is accepted by LUMI, it will be allocated to a node within the <code>q_industry</code> partition. At present, the <code>nid002153</code> node is available for use, which is equipped with 128 CPU cores and 256 GiB of memory.</p> <p>Note</p> <p>For additional information:</p> <ul> <li>To check the <code>q_industry</code> partition's current limits and the list of nodes, use <code>sinfo -s q_industry</code>.</li> <li>To obtain information about the node <code>nid002153</code>, use <code>scontrol show node \"nid002153\"</code>.</li> </ul> <p>The second queue is Helmi's internal job queue. It consists of a simple first-in-first-out (FIFO) queue. Each job from LUMI that executes a quantum circuit on Helmi will be inserted into this queue. It's important to note that operations that retrieve data, such as shot results or calibration data, do not enter this queue. Furthermore, periodic calibration jobs, submitted from VTT's side, are interleaved with regular user jobs in Helmi's queue (see Calibration) as depicted in the picture below.</p> <p></p>"},{"location":"running/#web-interface","title":"Web-interface","text":"<p>The LUMI Web interface allows users to run on Helmi through their browser and use Jupyter notebooks for execution. Here is a brief guide, specifically for Helmi, however further details can be found here.</p> <p>Once you have logged in select the <code>Jupyter</code> option. The session should be configured by selecting your project and the partition. The partitions should be <code>q_fiqci</code> and  <code>q_industry</code> for use with Helmi. The resource limitations are described here. For use with Helmi some custom advanced settings should be configured.</p> <pre><code>module use /appl/local/quantum/modulefiles\nmodule load helmi_qiskit\n</code></pre> <p>This pictures below demonstrate the process.</p> <p></p> <p></p>"},{"location":"support/","title":"Support","text":"<p>For technical assistance in accessing LUMI or Helmi or running jobs on Helmi please contact servicedesk@csc.fi.</p>"},{"location":"examples/","title":"Examples","text":"<p>Here you will find a list of examples of using VTT's Quantum computers. Additional examples can also be found in the FiQCI examples page.</p>"},{"location":"examples/#general","title":"General","text":"<ul> <li>Introduction to Helmi with Qiskit</li> <li>Introduction to Helmi with Cirq</li> <li>Visualizing Quality Metrics</li> </ul>"},{"location":"examples/intro-to-helmi-cirq/","title":"Introduction to Helmi with Cirq","text":"In\u00a0[\u00a0]: Copied! <pre>import cirq\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport numpy as np\nfrom cirq.contrib.svg import SVGCircuit\nfrom iqm.cirq_iqm.iqm_sampler import IQMSampler\nfrom iqm.cirq_iqm.optimizers import simplify_circuit\n</pre> import cirq import matplotlib.pyplot as plt import networkx as nx import numpy as np from cirq.contrib.svg import SVGCircuit from iqm.cirq_iqm.iqm_sampler import IQMSampler from iqm.cirq_iqm.optimizers import simplify_circuit <p>Then connection to the backend is simple! For this we point the <code>IQMSampler</code> at what is called \"cocos URL\". The cocos url to access Helmi is provided below.</p> In\u00a0[\u00a0]: Copied! <pre>sampler = IQMSampler(\"https://qc.vtt.fi/helmi/cocos\")\ndevice = sampler.device\n</pre> sampler = IQMSampler(\"https://qc.vtt.fi/helmi/cocos\") device = sampler.device <p>We can also specify a <code>calibration_set_id</code> and whether to run with <code>max_circuit_duration_over_t2</code> or not. The <code>max_circuit_duration_over_t2</code> option when set to <code>1.0</code> disqualifies any circuits that are too long compared to the coherence time of the qubits.</p> In\u00a0[\u00a0]: Copied! <pre>sampler = IQMSampler(\n    \"https://qc.vtt.fi/helmi/cocos\",\n    calibration_set_id=\"2318283e-3adf-4a88-a936-a33affde4af7\",\n    max_circuit_duration_over_t2=1.0,\n    heralding_mode=\"zeros\",\n)\n</pre> sampler = IQMSampler(     \"https://qc.vtt.fi/helmi/cocos\",     calibration_set_id=\"2318283e-3adf-4a88-a936-a33affde4af7\",     max_circuit_duration_over_t2=1.0,     heralding_mode=\"zeros\", ) <p>Now that we have connected to Helmi, we can query for some information about Helmi!</p> In\u00a0[\u00a0]: Copied! <pre>print(f\"Native operations: {device.metadata.gateset}\")\nprint(f\"Number of qubits: {device.qubits}\")\nprint(f\"Coupling map: {device.metadata.nx_graph.edges}\")\n</pre> print(f\"Native operations: {device.metadata.gateset}\") print(f\"Number of qubits: {device.qubits}\") print(f\"Coupling map: {device.metadata.nx_graph.edges}\") <p>The topology can be visualized with <code>networkx</code>.</p> In\u00a0[\u00a0]: Copied! <pre>G = nx.Graph()\nG.add_edges_from(device.metadata.nx_graph.edges)\nnode_labels = {node: str(node) for node in G.nodes}\nnx.draw(\n    G,\n    labels=node_labels,\n    node_color=\"skyblue\",\n    node_size=500,\n    font_size=10,\n    with_labels=True,\n)\n</pre> G = nx.Graph() G.add_edges_from(device.metadata.nx_graph.edges) node_labels = {node: str(node) for node in G.nodes} nx.draw(     G,     labels=node_labels,     node_color=\"skyblue\",     node_size=500,     font_size=10,     with_labels=True, ) In\u00a0[\u00a0]: Copied! <pre>q1, q2 = cirq.NamedQubit(\"Alice\"), cirq.NamedQubit(\"Bob\")\ncircuit = cirq.Circuit()\ncircuit.append(cirq.H(q1))\ncircuit.append(cirq.CNOT(q1, q2))\ncircuit.append(cirq.measure(q1, q2, key=\"m\"))\n\nSVGCircuit(circuit)\n</pre> q1, q2 = cirq.NamedQubit(\"Alice\"), cirq.NamedQubit(\"Bob\") circuit = cirq.Circuit() circuit.append(cirq.H(q1)) circuit.append(cirq.CNOT(q1, q2)) circuit.append(cirq.measure(q1, q2, key=\"m\"))  SVGCircuit(circuit) <p>First we'll transpile the circuit into Helmi's native gates</p> In\u00a0[\u00a0]: Copied! <pre>decomposed_circuit = device.decompose_circuit(circuit)\nSVGCircuit(decomposed_circuit)\n</pre> decomposed_circuit = device.decompose_circuit(circuit) SVGCircuit(decomposed_circuit) <p>Then we route the circuit based on Helmi's topology</p> In\u00a0[\u00a0]: Copied! <pre>routed_circuit, initial_mapping, final_mapping = device.route_circuit(decomposed_circuit)\nSVGCircuit(routed_circuit)\n</pre> routed_circuit, initial_mapping, final_mapping = device.route_circuit(decomposed_circuit) SVGCircuit(routed_circuit) <p>By printing the initial mapping we can see how the qubit names have beemn translated into the names of the qubits physically on Helmi and how the original qubit names were routed onto the device.</p> In\u00a0[\u00a0]: Copied! <pre>print(initial_mapping)\n</pre> print(initial_mapping) <p>This circuit can be executed on Helmi, but as an additional step we can simplify the circuit, using cirq-on-iqm's built in optimizers.</p> In\u00a0[\u00a0]: Copied! <pre>simplified_circuit = simplify_circuit(routed_circuit)\nSVGCircuit(simplified_circuit)\n</pre> simplified_circuit = simplify_circuit(routed_circuit) SVGCircuit(simplified_circuit) <p>The circuits can then be executed by calling <code>sampler.run</code>. Additionally, a folding function can be passed to process the sampled measurement results and convert the results into a format suitable for plotting for example.</p> In\u00a0[\u00a0]: Copied! <pre>def fold_func(x: np.ndarray) -&gt; str:\n    \"\"\"Fold the measured bit arrays into strings.\"\"\"\n    return \"\".join(map(lambda x: chr(x + ord(\"0\")), x))\n\n\nresult = sampler.run(simplified_circuit, repetitions=100)\n# print(result.measurements['m'])\nprint(result.histogram(key=\"m\", fold_func=fold_func))\n</pre> def fold_func(x: np.ndarray) -&gt; str:     \"\"\"Fold the measured bit arrays into strings.\"\"\"     return \"\".join(map(lambda x: chr(x + ord(\"0\")), x))   result = sampler.run(simplified_circuit, repetitions=100) # print(result.measurements['m']) print(result.histogram(key=\"m\", fold_func=fold_func)) <p>A histogram of the results can be plotted using <code>plot_state_histogram</code>.</p> In\u00a0[\u00a0]: Copied! <pre>def binary_labels(num_qubits):\n    return [bin(x)[2:].zfill(num_qubits) for x in range(2**num_qubits)]\n\n\ncirq.plot_state_histogram(result, plt.subplot(), tick_label=binary_labels(2))\n</pre> def binary_labels(num_qubits):     return [bin(x)[2:].zfill(num_qubits) for x in range(2**num_qubits)]   cirq.plot_state_histogram(result, plt.subplot(), tick_label=binary_labels(2)) <p>Additional metadata about the executed job can also be found.</p> In\u00a0[\u00a0]: Copied! <pre>print(\"Job ID: \", result.metadata.job_id)  # Retrieving the submitted job id\nprint(\n    \"Calibration Set ID: \", result.metadata.calibration_set_id\n)  # Retrieving the current calibration set id.\n</pre> print(\"Job ID: \", result.metadata.job_id)  # Retrieving the submitted job id print(     \"Calibration Set ID: \", result.metadata.calibration_set_id )  # Retrieving the current calibration set id. In\u00a0[\u00a0]: Copied! <pre>circuit_list = []\n\nq1, q2 = cirq.NamedQubit(\"Alice\"), cirq.NamedQubit(\"Bob\")\ncircuit_1 = cirq.Circuit()\ncircuit_1.append(cirq.H(q1))\ncircuit_1.append(cirq.CNOT(q1, q2))\ncircuit_1.append(cirq.measure(q1, q2, key=\"m\"))\n\nSVGCircuit(circuit_1)\n\ncircuit_2 = cirq.Circuit()\ncircuit_2.append(cirq.H(q1))\ncircuit_2.append(cirq.CNOT(q2, q1))\ncircuit_2.append(cirq.measure(q1, q2, key=\"m\"))\n\nSVGCircuit(circuit_2)\n\nrouted_circuit_1, _, _ = device.route_circuit(device.decompose_circuit(circuit_1))\nrouted_circuit_2, _, _ = device.route_circuit(device.decompose_circuit(circuit_2))\n\ncircuit_list.append(routed_circuit_1)\ncircuit_list.append(routed_circuit_2)\n\nresults = sampler.run_iqm_batch(circuit_list, repetitions=10)\n\nfor result in results:\n    print(result.histogram(key=\"m\"))\n</pre> circuit_list = []  q1, q2 = cirq.NamedQubit(\"Alice\"), cirq.NamedQubit(\"Bob\") circuit_1 = cirq.Circuit() circuit_1.append(cirq.H(q1)) circuit_1.append(cirq.CNOT(q1, q2)) circuit_1.append(cirq.measure(q1, q2, key=\"m\"))  SVGCircuit(circuit_1)  circuit_2 = cirq.Circuit() circuit_2.append(cirq.H(q1)) circuit_2.append(cirq.CNOT(q2, q1)) circuit_2.append(cirq.measure(q1, q2, key=\"m\"))  SVGCircuit(circuit_2)  routed_circuit_1, _, _ = device.route_circuit(device.decompose_circuit(circuit_1)) routed_circuit_2, _, _ = device.route_circuit(device.decompose_circuit(circuit_2))  circuit_list.append(routed_circuit_1) circuit_list.append(routed_circuit_2)  results = sampler.run_iqm_batch(circuit_list, repetitions=10)  for result in results:     print(result.histogram(key=\"m\"))"},{"location":"examples/intro-to-helmi-cirq/#introduction-to-helmi-with-cirq","title":"Introduction to Helmi with Cirq\u00b6","text":"<p>Helmi is a 5 qubit Quantum Computer that is co-developed by VTT and IQM. It uses superconducting transmon qubits in a star shaped topology. Helmi's natives gates consist of the phased-rx and controlled-z gates. This architecture is called Adonis by IQM.</p> <p>In this tutorial running on Helmi is demonstrated using the Cirq framework. You can also run on Helmi using Qiskit with the qiskit-on-iqm adapter, and this is described in a separate notebook.</p> <p>Here is Helmi!</p>"},{"location":"examples/intro-to-helmi-cirq/#setup","title":"Setup\u00b6","text":"<p>This notebook uses the following requirements.</p> <pre>cirq-iqm==14.0\niqm-client==17.5\n</pre>"},{"location":"examples/intro-to-helmi-cirq/#using-helmi-with-cirq","title":"Using Helmi with Cirq\u00b6","text":"<p>First we import cirq-on-iqm which is needed to run on Helmi with cirq. You can read the user guide here.</p>"},{"location":"examples/intro-to-helmi-cirq/#constructing-and-executing-quantum-circuits","title":"Constructing and executing quantum circuits\u00b6","text":"<p>Circuits are constructed in Cirq by decomposing and routing them for the target topology. Additionally, you can run some simple optimization routines to get better performance for your circuit.</p>"},{"location":"examples/intro-to-helmi-cirq/#batch-execution","title":"Batch execution\u00b6","text":"<p>Helmi also allows for batches of circuits to be submitted with 1 call to the quantum computer. A batch is simply a list of circuits. This is often faster than executing circuits individually, however, circuits will still be executed sequentially. On Helmi currently you can only place a maximum of 20 circuits in one batch. All circuits in a batch are executed with the same number of shots. The maximum number of shots per circuit is 100,000.</p> <p>With cirq this is implemented via the <code>run_iqm_batch</code> method of <code>sampler</code>.</p> <p>Batch submission of circuits allows parameterized circuits to be executed using the <code>cirq-resolve_parameters</code> function.</p>"},{"location":"examples/intro-to-helmi-cirq/#summary","title":"Summary\u00b6","text":"<p>In this notebook we have demonstrated how to connect and run circuits on Helmi with Cirq using the cirq-on-iqm adapter.</p>"},{"location":"examples/intro-to-helmi-cirq/#additional-reading","title":"Additional Reading\u00b6","text":"<ul> <li>Long-distance transmon coupler with CZ gate fidelity above 99.8%. Paper by IQM describing the superconducting technology behind Helmi.</li> <li>Helmi press release.</li> <li>cirq-on-iqm Github page.</li> <li>cirq-on-iqm documentation. We are running <code>11.13</code>.</li> <li>CSC documentation on Helmi.</li> </ul>"},{"location":"examples/intro-to-helmi-qiskit/","title":"Introduction to Helmi with Qiskit","text":"In\u00a0[\u00a0]: Copied! <pre>import networkx as nx\nfrom iqm.qiskit_iqm import IQMProvider\nfrom iqm.qiskit_iqm.iqm_transpilation import optimize_single_qubit_gates\nfrom qiskit import QuantumCircuit, QuantumRegister, execute, transpile\nfrom qiskit.tools.monitor import job_monitor\nfrom qiskit.visualization import plot_histogram\n</pre> import networkx as nx from iqm.qiskit_iqm import IQMProvider from iqm.qiskit_iqm.iqm_transpilation import optimize_single_qubit_gates from qiskit import QuantumCircuit, QuantumRegister, execute, transpile from qiskit.tools.monitor import job_monitor from qiskit.visualization import plot_histogram <p>Then connection to the backend is simple! For this we point the <code>IQMProvider</code> at what is called the \"cocos URL\". The cocos url to access Helmi is provided below.</p> In\u00a0[\u00a0]: Copied! <pre>provider = IQMProvider(\"https://qc.vtt.fi/helmi/cocos\")\nbackend = provider.get_backend()\n</pre> provider = IQMProvider(\"https://qc.vtt.fi/helmi/cocos\") backend = provider.get_backend() <p>Now that we have the backend connected to Helmi, let's print out some information about Helmi!</p> In\u00a0[\u00a0]: Copied! <pre>print(f\"Native operations: {backend.operation_names}\")\nprint(f\"Number of qubits: {backend.num_qubits}\")\nprint(f\"Coupling map: {backend.coupling_map}\")\n</pre> print(f\"Native operations: {backend.operation_names}\") print(f\"Number of qubits: {backend.num_qubits}\") print(f\"Coupling map: {backend.coupling_map}\") <p>Visualising the topology with <code>networkx</code>:</p> In\u00a0[\u00a0]: Copied! <pre>G = nx.Graph()\nG.add_edges_from(backend.coupling_map)\nnode_labels = {node: f\"QB{node + 1}\" for node in G.nodes}\nnx.draw(G, labels=node_labels, node_color=\"skyblue\", node_size=500, font_size=10)\n</pre> G = nx.Graph() G.add_edges_from(backend.coupling_map) node_labels = {node: f\"QB{node + 1}\" for node in G.nodes} nx.draw(G, labels=node_labels, node_color=\"skyblue\", node_size=500, font_size=10) In\u00a0[\u00a0]: Copied! <pre>circuit = QuantumCircuit(2, name=\"Bell pair circuit\")\ncircuit.h(0)\ncircuit.cx(0, 1)\ncircuit.measure_all()\ncircuit.draw(output=\"mpl\")\n</pre> circuit = QuantumCircuit(2, name=\"Bell pair circuit\") circuit.h(0) circuit.cx(0, 1) circuit.measure_all() circuit.draw(output=\"mpl\") In\u00a0[\u00a0]: Copied! <pre>job = execute(circuit, backend, shots=100)\nprint(f\"Job ID: {job.job_id()}.\")\nprint(\"Tracking execution of job:\")\njob_monitor(job)\n</pre> job = execute(circuit, backend, shots=100) print(f\"Job ID: {job.job_id()}.\") print(\"Tracking execution of job:\") job_monitor(job) <p>The <code>execute</code> function from qiskit performs the quantum circuit transpilation by default. If you want to inspect the transpiled circuit, the <code>circuit_callback</code> option can be used. To run without automatic transpilation, <code>backend.run</code> can be used directly, in which case transpilation must be performed manually.</p> In\u00a0[\u00a0]: Copied! <pre>def print_circ(circuit):\n    for qc in circuit:\n        print(qc.draw())\n\n\njob = execute(circuit, backend, shots=100, circuit_callback=print_circ)\nprint(f\"Job ID: {job.job_id()}.\")\nprint(\"Tracking execution of job:\")\njob_monitor(job)\n</pre> def print_circ(circuit):     for qc in circuit:         print(qc.draw())   job = execute(circuit, backend, shots=100, circuit_callback=print_circ) print(f\"Job ID: {job.job_id()}.\") print(\"Tracking execution of job:\") job_monitor(job) In\u00a0[\u00a0]: Copied! <pre>result = job.result()\nprint(result.job_id)  # The job id can be queried from the result\nprint(result.get_counts())\n# print(result.get_memory())\n\nplot_histogram(result.get_counts())\n</pre> result = job.result() print(result.job_id)  # The job id can be queried from the result print(result.get_counts()) # print(result.get_memory())  plot_histogram(result.get_counts()) <p>You can also specify some backend arguments for running on Helmi. These are explained in the qiskit-on-iqm documentation.</p> In\u00a0[\u00a0]: Copied! <pre># job = execute(\n#     circuit,\n#     backend,\n#     shots=100,\n#     calibration_set_id=\"c5a5e2d1-100b-42d4-a4fd-a49edfb9d176\",\n#     max_circuit_duration_over_t2=1.0,\n#     heralding_mode=\"zeros\",\n#     circuit_callback=None,\n# )\n</pre> # job = execute( #     circuit, #     backend, #     shots=100, #     calibration_set_id=\"c5a5e2d1-100b-42d4-a4fd-a49edfb9d176\", #     max_circuit_duration_over_t2=1.0, #     heralding_mode=\"zeros\", #     circuit_callback=None, # ) <p>After submitting, the job is now running. The status of the job can be queried using <code>job.status()</code>. Using the job id, you can retrieve previous jobs.</p> In\u00a0[\u00a0]: Copied! <pre>status = job.status()\nprint(status)\n# old_job = backend.retrieve_job(job_id)\n</pre> status = job.status() print(status) # old_job = backend.retrieve_job(job_id) <p>Instead of using the <code>execute</code> function you can also be explicit about your transpilation.</p> In\u00a0[\u00a0]: Copied! <pre>transpiled_circuit = transpile(\n    circuit, backend=backend, layout_method=\"sabre\", optimization_level=3\n)\ntranspiled_circuit.draw(\"mpl\")\n</pre> transpiled_circuit = transpile(     circuit, backend=backend, layout_method=\"sabre\", optimization_level=3 ) transpiled_circuit.draw(\"mpl\") <p>For more control, you can also specify the initial layout in both <code>transpile</code> and <code>execute</code>. For example, Helmi's topology only allows 2 qubit gates between the central and outer qubits. Therefore we can map the 2 qubit gate to QB3.  For this we make use of the <code>QuantumRegister</code>.</p> In\u00a0[\u00a0]: Copied! <pre>qreg = QuantumRegister(2, \"QB\")\ncircuit = QuantumCircuit(qreg, name=\"Bell pair circuit\")\ncircuit.h(qreg[0])\ncircuit.cx(qreg[0], qreg[1])\ncircuit.measure_all()\n\n\n# Qubit numbers start at 0 index whereas the qubit names start at 1 index.\nqubit_mapping = {\n    qreg[0]: 1,  # Map the first qubit to QB1\n    qreg[1]: 2,  # Map the second qubit to QB3\n}\n\n\njob = execute(circuit, backend, shots=100, initial_layout=qubit_mapping)\n</pre> qreg = QuantumRegister(2, \"QB\") circuit = QuantumCircuit(qreg, name=\"Bell pair circuit\") circuit.h(qreg[0]) circuit.cx(qreg[0], qreg[1]) circuit.measure_all()   # Qubit numbers start at 0 index whereas the qubit names start at 1 index. qubit_mapping = {     qreg[0]: 1,  # Map the first qubit to QB1     qreg[1]: 2,  # Map the second qubit to QB3 }   job = execute(circuit, backend, shots=100, initial_layout=qubit_mapping) <p>Qiskit refers to qubits using integer indices, whereas IQM uses strings. The backend class provides utility methods for mapping them to one another. Let's see on which physical qubits the logical circuit qubits were mapped.</p> In\u00a0[\u00a0]: Copied! <pre>mapping = {}\nfor qubit in circuit.qubits:\n    index = circuit.find_bit(qubit).index\n    mapping[index] = backend.index_to_qubit_name(index)\n\nprint(mapping)\n</pre> mapping = {} for qubit in circuit.qubits:     index = circuit.find_bit(qubit).index     mapping[index] = backend.index_to_qubit_name(index)  print(mapping) In\u00a0[\u00a0]: Copied! <pre>circuit_optimized = optimize_single_qubit_gates(transpiled_circuit)\ncircuit_optimized.draw(\"mpl\")\n</pre> circuit_optimized = optimize_single_qubit_gates(transpiled_circuit) circuit_optimized.draw(\"mpl\") In\u00a0[\u00a0]: Copied! <pre>result = job.result()\nprint(result.job_id)  # The job id can be queried from the result\nprint(result.get_counts())\n# print(result.get_memory())\n\nplot_histogram(result.get_counts())\n</pre> result = job.result() print(result.job_id)  # The job id can be queried from the result print(result.get_counts()) # print(result.get_memory())  plot_histogram(result.get_counts()) <p>Additional metadata about the executed job can also be found.</p> In\u00a0[\u00a0]: Copied! <pre>exp_result = result._get_experiment(circuit)\nprint(\"Job ID: \", job.job_id())  # Retrieving the submitted job id\nprint(result.request.circuits)  # Retrieving the circuit request sent\nprint(\n    \"Calibration Set ID: \", exp_result.calibration_set_id\n)  # Retrieving the current calibration set id.\nprint(result.request.qubit_mapping)  # Retrieving the qubit mapping\nprint(result.request.shots)  # Retrieving the number of requested shots.\nprint(exp_result.header)\n</pre> exp_result = result._get_experiment(circuit) print(\"Job ID: \", job.job_id())  # Retrieving the submitted job id print(result.request.circuits)  # Retrieving the circuit request sent print(     \"Calibration Set ID: \", exp_result.calibration_set_id )  # Retrieving the current calibration set id. print(result.request.qubit_mapping)  # Retrieving the qubit mapping print(result.request.shots)  # Retrieving the number of requested shots. print(exp_result.header) In\u00a0[\u00a0]: Copied! <pre>from iqm.qiskit_iqm import IQMFakeAdonis\n\nfake_backend = IQMFakeAdonis()\njob = execute(circuit, fake_backend, shots=1000)\nprint(job.result().get_counts())\nplot_histogram(job.result().get_counts())\n</pre> from iqm.qiskit_iqm import IQMFakeAdonis  fake_backend = IQMFakeAdonis() job = execute(circuit, fake_backend, shots=1000) print(job.result().get_counts()) plot_histogram(job.result().get_counts()) <p>The error profile of the noise can be queried and customised by the user following the qiskit-iqm user guide.</p> In\u00a0[\u00a0]: Copied! <pre>print(fake_backend.error_profile)\n</pre> print(fake_backend.error_profile) In\u00a0[\u00a0]: Copied! <pre>error_profile = fake_backend.error_profile\nerror_profile.t1s[\"QB1\"] = 38940.0  # in ns 3.8940\nerror_profile.t1s[\"QB2\"] = 25127.0  # in ns\nerror_profile.t1s[\"QB3\"] = 43322.0  # in ns\nerror_profile.t1s[\"QB4\"] = 38223.0  # in ns\nerror_profile.t1s[\"QB5\"] = 37365.0  # in ns\n\nerror_profile.t2s[\"QB1\"] = 24785.0  # in ns\nerror_profile.t2s[\"QB2\"] = 20751.0  # in ns\nerror_profile.t2s[\"QB3\"] = 10050.0  # in ns\nerror_profile.t2s[\"QB4\"] = 14391.0  # in ns\nerror_profile.t2s[\"QB5\"] = 29012.0  # in ns\n\nerror_profile.single_qubit_gate_depolarizing_error_parameters[\"prx\"][\"QB1\"] = 0.0043\nerror_profile.single_qubit_gate_depolarizing_error_parameters[\"prx\"][\"QB2\"] = 0.0018\nerror_profile.single_qubit_gate_depolarizing_error_parameters[\"prx\"][\"QB3\"] = 0.0022\nerror_profile.single_qubit_gate_depolarizing_error_parameters[\"prx\"][\"QB4\"] = 0.0037\nerror_profile.single_qubit_gate_depolarizing_error_parameters[\"prx\"][\"QB5\"] = 0.0024\n\nerror_profile.two_qubit_gate_depolarizing_error_parameters[\"cz\"][(\"QB1\", \"QB3\")] = 0.018\nerror_profile.two_qubit_gate_depolarizing_error_parameters[\"cz\"][(\"QB2\", \"QB3\")] = 0.033\nerror_profile.two_qubit_gate_depolarizing_error_parameters[\"cz\"][(\"QB3\", \"QB4\")] = 0.030\nerror_profile.two_qubit_gate_depolarizing_error_parameters[\"cz\"][(\"QB3\", \"QB5\")] = 0.017\n\nerror_profile.single_qubit_gate_durations[\"prx\"] = 120  # in ns\nerror_profile.two_qubit_gate_durations[\"cz\"] = 120  # in ns\n\nerror_profile.readout_errors[\"QB1\"][\"0\"] = 0.03375\nerror_profile.readout_errors[\"QB1\"][\"1\"] = 0.03865\nerror_profile.readout_errors[\"QB2\"][\"0\"] = 0.032\nerror_profile.readout_errors[\"QB2\"][\"1\"] = 0.0520\nerror_profile.readout_errors[\"QB3\"][\"0\"] = 0.0365\nerror_profile.readout_errors[\"QB3\"][\"1\"] = 0.05885\nerror_profile.readout_errors[\"QB4\"][\"0\"] = 0.03735\nerror_profile.readout_errors[\"QB4\"][\"1\"] = 0.06225\nerror_profile.readout_errors[\"QB5\"][\"0\"] = 0.04375\nerror_profile.readout_errors[\"QB5\"][\"1\"] = 0.05689\n\nerror_profile.name = \"fake_helmi\"\n\n\nhelmi_fake_backend = fake_backend.copy_with_error_profile(error_profile)\n</pre> error_profile = fake_backend.error_profile error_profile.t1s[\"QB1\"] = 38940.0  # in ns 3.8940 error_profile.t1s[\"QB2\"] = 25127.0  # in ns error_profile.t1s[\"QB3\"] = 43322.0  # in ns error_profile.t1s[\"QB4\"] = 38223.0  # in ns error_profile.t1s[\"QB5\"] = 37365.0  # in ns  error_profile.t2s[\"QB1\"] = 24785.0  # in ns error_profile.t2s[\"QB2\"] = 20751.0  # in ns error_profile.t2s[\"QB3\"] = 10050.0  # in ns error_profile.t2s[\"QB4\"] = 14391.0  # in ns error_profile.t2s[\"QB5\"] = 29012.0  # in ns  error_profile.single_qubit_gate_depolarizing_error_parameters[\"prx\"][\"QB1\"] = 0.0043 error_profile.single_qubit_gate_depolarizing_error_parameters[\"prx\"][\"QB2\"] = 0.0018 error_profile.single_qubit_gate_depolarizing_error_parameters[\"prx\"][\"QB3\"] = 0.0022 error_profile.single_qubit_gate_depolarizing_error_parameters[\"prx\"][\"QB4\"] = 0.0037 error_profile.single_qubit_gate_depolarizing_error_parameters[\"prx\"][\"QB5\"] = 0.0024  error_profile.two_qubit_gate_depolarizing_error_parameters[\"cz\"][(\"QB1\", \"QB3\")] = 0.018 error_profile.two_qubit_gate_depolarizing_error_parameters[\"cz\"][(\"QB2\", \"QB3\")] = 0.033 error_profile.two_qubit_gate_depolarizing_error_parameters[\"cz\"][(\"QB3\", \"QB4\")] = 0.030 error_profile.two_qubit_gate_depolarizing_error_parameters[\"cz\"][(\"QB3\", \"QB5\")] = 0.017  error_profile.single_qubit_gate_durations[\"prx\"] = 120  # in ns error_profile.two_qubit_gate_durations[\"cz\"] = 120  # in ns  error_profile.readout_errors[\"QB1\"][\"0\"] = 0.03375 error_profile.readout_errors[\"QB1\"][\"1\"] = 0.03865 error_profile.readout_errors[\"QB2\"][\"0\"] = 0.032 error_profile.readout_errors[\"QB2\"][\"1\"] = 0.0520 error_profile.readout_errors[\"QB3\"][\"0\"] = 0.0365 error_profile.readout_errors[\"QB3\"][\"1\"] = 0.05885 error_profile.readout_errors[\"QB4\"][\"0\"] = 0.03735 error_profile.readout_errors[\"QB4\"][\"1\"] = 0.06225 error_profile.readout_errors[\"QB5\"][\"0\"] = 0.04375 error_profile.readout_errors[\"QB5\"][\"1\"] = 0.05689  error_profile.name = \"fake_helmi\"   helmi_fake_backend = fake_backend.copy_with_error_profile(error_profile) In\u00a0[\u00a0]: Copied! <pre>job = execute(circuit, helmi_fake_backend, shots=1000)\nprint(job.result().get_counts())\nplot_histogram(job.result().get_counts())\n</pre> job = execute(circuit, helmi_fake_backend, shots=1000) print(job.result().get_counts()) plot_histogram(job.result().get_counts()) In\u00a0[\u00a0]: Copied! <pre>circuits_list = []\n\ncircuit_1 = QuantumCircuit(2, name=\"Bell pair circuit\")\ncircuit_1.h(0)\ncircuit_1.cx(0, 1)\ncircuit_1.measure_all()\ncircuits_list.append(circuit_1)\n\ncircuit_1.draw(output=\"mpl\")\n</pre> circuits_list = []  circuit_1 = QuantumCircuit(2, name=\"Bell pair circuit\") circuit_1.h(0) circuit_1.cx(0, 1) circuit_1.measure_all() circuits_list.append(circuit_1)  circuit_1.draw(output=\"mpl\") In\u00a0[\u00a0]: Copied! <pre>circuit_2 = QuantumCircuit(2, name=\"Reverse Bell pair circuit\")\ncircuit_2.h(1)\ncircuit_2.cx(1, 0)\ncircuit_2.measure_all()\ncircuits_list.append(circuit_2)\n\ncircuit_2.draw(output=\"mpl\")\n</pre> circuit_2 = QuantumCircuit(2, name=\"Reverse Bell pair circuit\") circuit_2.h(1) circuit_2.cx(1, 0) circuit_2.measure_all() circuits_list.append(circuit_2)  circuit_2.draw(output=\"mpl\") In\u00a0[\u00a0]: Copied! <pre># Execute and monitor job\njob = execute(\n    circuits_list, backend, shots=10, optimization_level=3, initial_layout=[0, 2]\n)\nprint(\"Tracking execution of job:\")\njob_monitor(job)\n</pre> # Execute and monitor job job = execute(     circuits_list, backend, shots=10, optimization_level=3, initial_layout=[0, 2] ) print(\"Tracking execution of job:\") job_monitor(job) In\u00a0[\u00a0]: Copied! <pre># Get results\nresult = job.result()\n\n# Plot histograms\nplot_histogram(result.get_counts(), legend=[\"Circuit 1\", \"Circuit 2\"])\n</pre> # Get results result = job.result()  # Plot histograms plot_histogram(result.get_counts(), legend=[\"Circuit 1\", \"Circuit 2\"]) In\u00a0[\u00a0]: Copied! <pre>import pennylane as qml\n\n# provider = IQMProvider(\"https://qc.vtt.fi/helmi/cocos\")\n# backend = provider.get_backend()\n\n\ndev = qml.device(\"qiskit.remote\", wires=5, backend=backend, shots=10)\n\nprint(dev.capabilities())\n\n\n@qml.qnode(dev, interface=\"autograd\")\ndef circuit(params):\n    qml.RX(params[0], wires=0)\n    qml.RY(params[1], wires=0)\n    return qml.expval(qml.PauliZ(0))\n\n\nprint(circuit([0.54, 0.12]))\n</pre> import pennylane as qml  # provider = IQMProvider(\"https://qc.vtt.fi/helmi/cocos\") # backend = provider.get_backend()   dev = qml.device(\"qiskit.remote\", wires=5, backend=backend, shots=10)  print(dev.capabilities())   @qml.qnode(dev, interface=\"autograd\") def circuit(params):     qml.RX(params[0], wires=0)     qml.RY(params[1], wires=0)     return qml.expval(qml.PauliZ(0))   print(circuit([0.54, 0.12]))"},{"location":"examples/intro-to-helmi-qiskit/#introduction-to-helmi-with-qiskit","title":"Introduction to Helmi with Qiskit\u00b6","text":"<p>Helmi is a 5 qubit Quantum Computer that is co-developed by VTT and IQM. It uses superconducting transmon qubits in a star shaped topology. Helmi's natives gates consist of the phased-rx and controlled-z gates. This architecture is called Adonis by IQM.</p> <p>In this tutorial running on Helmi is demonstrated using the Qiskit framework. You can also run on Helmi using Cirq with cirq-on-iqm adapter, and this is described in a separate notebook.</p> <p>Here is Helmi!</p>"},{"location":"examples/intro-to-helmi-qiskit/#setup","title":"Setup\u00b6","text":"<p>This notebook uses the following requirements.</p> <pre>qiskit-iqm==13.7\niqm-client==17.5\nqiskit[visualization]\npylatexenc\n</pre>"},{"location":"examples/intro-to-helmi-qiskit/#using-helmi-with-qiskit","title":"Using Helmi with Qiskit\u00b6","text":"<p>First we import qiskit-on-iqm which is needed to run on Helmi with qiskit. You can read the user guide here.</p>"},{"location":"examples/intro-to-helmi-qiskit/#constructing-and-executing-quantum-circuits","title":"Constructing and executing quantum circuits\u00b6","text":"<p>Circuits are constructed and submitted to Helmi using the same methods as with IBM machines. First we construct a Bell pair circuit between 2 qubits. The circuit is then executed on the backend using the <code>execute</code> function.</p>"},{"location":"examples/intro-to-helmi-qiskit/#executing-the-circuit-on-helmi","title":"Executing the circuit on Helmi\u00b6","text":"<p>When submitting a job to Helmi a unique identifier for your job is returned. This can be used to gather additional information about the circuit you just submitted and the results. You should save your job ids!</p>"},{"location":"examples/intro-to-helmi-qiskit/#viewing-the-results","title":"Viewing the results\u00b6","text":"<p>Results can be printed once the job has completed. If results are queried before the job has completed then an error will be returned.</p>"},{"location":"examples/intro-to-helmi-qiskit/#explicit-transpilation","title":"Explicit Transpilation\u00b6","text":""},{"location":"examples/intro-to-helmi-qiskit/#optimizing-circuits-for-helmi","title":"Optimizing circuits for Helmi\u00b6","text":"<p>Qiskit on IQM provides the option to optimize your transpiled quantum circuits for running on Helmi. Currently the optimization uses Qiskit's transpiler passes to reduce the number of single qubit gates in the quantum circuit, thus reducing the total circuit depth. Further information can be found in the IQM qiskit documentation.</p> <p>Here we optimize the previous instance of <code>transpiled_circuit</code> as the <code>optimize_single_qubit_gates</code> expected a transpiled circuit as an argument.</p>"},{"location":"examples/intro-to-helmi-qiskit/#results","title":"Results\u00b6","text":"<p>Results can be printed once the job has completed. If results are queried before the job has completed then an error will be returned.</p>"},{"location":"examples/intro-to-helmi-qiskit/#simulating-circuits-locally-with-noise","title":"Simulating circuits locally with noise\u00b6","text":"<p>Qiskit on IQM provides an <code>IQMFakeBackend</code> with <code>IQMFakeAdonis</code> for simulating Helmi.</p>"},{"location":"examples/intro-to-helmi-qiskit/#batch-execution","title":"Batch execution\u00b6","text":"<p>Helmi also allows for batches of circuits to be submitted with 1 call to the quantum computer. A batch is simply a list of <code>QuantumCircuits</code>. This is often faster than executing circuits individually, however, circuits will still be executed sequentially. On Helmi currently you can only place a maximum of 20 circuits in one batch. All circuits in a batch are executed with the same number of shots. The maximum number of shots per circuit is 100,000.</p> <p>All circuits in a batch must measure the same qubits. Adding the <code>initial_layout</code> argument when submitting ensures that you always measure the same qubits.</p> <p>Batch submission of circuits allows parameterized circuits to be executed using the <code>qiskit.circuit.Parameter</code> class.</p>"},{"location":"examples/intro-to-helmi-qiskit/#pennylane-qiskit","title":"Pennylane Qiskit\u00b6","text":"<p>You can also run Pennylane code on Helmi with the PennyLane-Qiskit Plugin. The <code>IQMBackend</code> object uses <code>BackendV2</code> currently which Pennylane-Qiskit does not support, therefore we use a forked-version that fixes this.</p>"},{"location":"examples/intro-to-helmi-qiskit/#summary","title":"Summary\u00b6","text":"<p>In this notebook we have demonstrated how to connect and run circuits on Helmi with Qiskit, qiskit-on-iqm and the PennyLane-Qiskit plugin.</p>"},{"location":"examples/intro-to-helmi-qiskit/#additional-reading","title":"Additional Reading\u00b6","text":"<ul> <li>Long-distance transmon coupler with CZ gate fidelity above 99.8%. Paper by IQM describing the superconducting technology behind Helmi.</li> <li>Helmi press release.</li> <li>qiskit-on-iqm Github page.</li> <li>qiskit-on-iqm documentation.</li> <li>CSC documentation on Helmi.</li> <li>Pennylane-Qiskit documentation.</li> </ul>"},{"location":"examples/visualize_quality_metrics/","title":"Visualizing Quality Metrics","text":"In\u00a0[\u00a0]: Copied! <pre>import json\nimport os\n\nimport matplotlib.pyplot as plt\nimport requests\nfrom iqm.iqm_client import IQMClient\nfrom iqm.qiskit_iqm import IQMProvider\n</pre> import json import os  import matplotlib.pyplot as plt import requests from iqm.iqm_client import IQMClient from iqm.qiskit_iqm import IQMProvider In\u00a0[\u00a0]: Copied! <pre>def get_calibration_data(\n    client: IQMClient, calibration_set_id=None, filename: str = None\n):\n    \"\"\"\n    Return the calibration data and figures of merit using IQMClient.\n    Optionally you can input a calibration set id (UUID) to query historical results\n    Optionally save the response to a json file, if filename is provided\n    \"\"\"\n    headers = {\"User-Agent\": client._signature}\n    bearer_token = client._get_bearer_token()\n    headers[\"Authorization\"] = bearer_token\n\n    if calibration_set_id:\n        url = os.path.join(client._base_url, \"calibration/metrics/\", calibration_set_id)\n    else:\n        url = os.path.join(client._base_url, \"calibration/metrics/latest\")\n\n    response = requests.get(url, headers=headers)\n    response.raise_for_status()  # will raise an HTTPError if the response was not ok\n\n    data = response.json()\n    data_str = json.dumps(data, indent=4)\n\n    if filename:\n        with open(filename, \"w\") as f:\n            f.write(data_str)\n        print(f\"Data saved to {filename}\")\n\n    return data\n</pre> def get_calibration_data(     client: IQMClient, calibration_set_id=None, filename: str = None ):     \"\"\"     Return the calibration data and figures of merit using IQMClient.     Optionally you can input a calibration set id (UUID) to query historical results     Optionally save the response to a json file, if filename is provided     \"\"\"     headers = {\"User-Agent\": client._signature}     bearer_token = client._get_bearer_token()     headers[\"Authorization\"] = bearer_token      if calibration_set_id:         url = os.path.join(client._base_url, \"calibration/metrics/\", calibration_set_id)     else:         url = os.path.join(client._base_url, \"calibration/metrics/latest\")      response = requests.get(url, headers=headers)     response.raise_for_status()  # will raise an HTTPError if the response was not ok      data = response.json()     data_str = json.dumps(data, indent=4)      if filename:         with open(filename, \"w\") as f:             f.write(data_str)         print(f\"Data saved to {filename}\")      return data In\u00a0[\u00a0]: Copied! <pre>provider = IQMProvider(\"https://qc.vtt.fi/helmi/cocos\")\nbackend = provider.get_backend()\n\n# If you receive an error you may need to set the IQM_TOKENS_FILE environment variable\n# os.environ[\"IQM_TOKENS_FILE\"] = \"/path/to/file\"\n</pre> provider = IQMProvider(\"https://qc.vtt.fi/helmi/cocos\") backend = provider.get_backend()  # If you receive an error you may need to set the IQM_TOKENS_FILE environment variable # os.environ[\"IQM_TOKENS_FILE\"] = \"/path/to/file\" <p>We can then get the raw calibration data and see what it looks like</p> In\u00a0[\u00a0]: Copied! <pre>calibration_data = get_calibration_data(backend.client)\n\nprint(calibration_data)\n</pre> calibration_data = get_calibration_data(backend.client)  print(calibration_data) <p>Here are the alternative options</p> In\u00a0[\u00a0]: Copied! <pre># cal_set_id = \"1b7b8415-1ec6-41d5-8c11-9800c111612c\"\n# calibration_data = get_calibration_data(backend.client, cal_set_id)\n# calibration_data = get_calibration_data(\n#     backend.client, cal_set_id, filename=f\"{cal_set_id}.json\"\n# )\n</pre> # cal_set_id = \"1b7b8415-1ec6-41d5-8c11-9800c111612c\" # calibration_data = get_calibration_data(backend.client, cal_set_id) # calibration_data = get_calibration_data( #     backend.client, cal_set_id, filename=f\"{cal_set_id}.json\" # ) <p>We can parse this data to see individual metrics and values. For example:</p> In\u00a0[\u00a0]: Copied! <pre>calibration_data[\"metrics\"]\n</pre> calibration_data[\"metrics\"] <p>The data is in the format</p> <pre>{\n  'component.metric':\n  {\n    'value': '1',\n    'unit': '',\n    'uncertainity': '',\n    'timestamp': '2024-04-08T05:05:47.58068'\n  }\n}\n</pre> In\u00a0[\u00a0]: Copied! <pre>def plot_metrics(\n    metric: str, title: str, ylabel: str, xlabel: str, data: dict, limits: list = []\n):\n    # Initialize lists to store the values and labels\n    values = []\n    labels = []\n\n    # Iterate over the calibration data and collect values and labels based on the metric\n    for key, metric_data in data[\"metrics\"].items():\n        if key.endswith(metric):\n            values.append(float(metric_data[\"value\"]))\n            # Extract the qubit label from the key\n            labels.append(key.split(\".\")[0])\n\n    # Check if values were found for the given metric\n    if not values:\n        return f\"{metric} not in quality metrics set!\"\n\n    # Set the width and gap between the bars\n    bar_width = 0.4\n    # Calculate the positions of the bars\n    positions = range(len(values))\n    # Plot the values with labels\n    plt.bar(positions, values, width=bar_width, tick_label=labels)\n\n    if len(limits) == 2:\n        plt.ylim(limits)\n\n    plt.grid(axis=\"y\")\n    plt.xlabel(xlabel)\n    plt.ylabel(ylabel)\n    plt.title(title)\n    plt.xticks(rotation=90)\n\n    plt.tight_layout()\n    plt.show()\n</pre> def plot_metrics(     metric: str, title: str, ylabel: str, xlabel: str, data: dict, limits: list = [] ):     # Initialize lists to store the values and labels     values = []     labels = []      # Iterate over the calibration data and collect values and labels based on the metric     for key, metric_data in data[\"metrics\"].items():         if key.endswith(metric):             values.append(float(metric_data[\"value\"]))             # Extract the qubit label from the key             labels.append(key.split(\".\")[0])      # Check if values were found for the given metric     if not values:         return f\"{metric} not in quality metrics set!\"      # Set the width and gap between the bars     bar_width = 0.4     # Calculate the positions of the bars     positions = range(len(values))     # Plot the values with labels     plt.bar(positions, values, width=bar_width, tick_label=labels)      if len(limits) == 2:         plt.ylim(limits)      plt.grid(axis=\"y\")     plt.xlabel(xlabel)     plt.ylabel(ylabel)     plt.title(title)     plt.xticks(rotation=90)      plt.tight_layout()     plt.show() In\u00a0[\u00a0]: Copied! <pre>plot_metrics(\n    metric=\"single_shot_readout_fidelity\",\n    title=\"Single Shot Readout Fidelities\",\n    xlabel=\"Qubits\",\n    ylabel=\"Success rate\",\n    data=calibration_data,\n    limits=[0.85, 1],\n)\n</pre> plot_metrics(     metric=\"single_shot_readout_fidelity\",     title=\"Single Shot Readout Fidelities\",     xlabel=\"Qubits\",     ylabel=\"Success rate\",     data=calibration_data,     limits=[0.85, 1], ) In\u00a0[\u00a0]: Copied! <pre>plot_metrics(\n    metric=\"t1_time\",\n    title=\"T1 times\",\n    xlabel=\"Qubits\",\n    ylabel=\"Time\",\n    data=calibration_data,\n)\n</pre> plot_metrics(     metric=\"t1_time\",     title=\"T1 times\",     xlabel=\"Qubits\",     ylabel=\"Time\",     data=calibration_data, ) In\u00a0[\u00a0]: Copied! <pre>plot_metrics(\n    metric=\"t2_time\",\n    title=\"T2 times\",\n    xlabel=\"Qubits\",\n    ylabel=\"Time\",\n    data=calibration_data,\n)\n</pre> plot_metrics(     metric=\"t2_time\",     title=\"T2 times\",     xlabel=\"Qubits\",     ylabel=\"Time\",     data=calibration_data, ) In\u00a0[\u00a0]: Copied! <pre>plot_metrics(\n    metric=\"t2_echo_time\",\n    title=\"T2 Echo times\",\n    xlabel=\"Qubits\",\n    ylabel=\"Time\",\n    data=calibration_data,\n)\n</pre> plot_metrics(     metric=\"t2_echo_time\",     title=\"T2 Echo times\",     xlabel=\"Qubits\",     ylabel=\"Time\",     data=calibration_data, ) In\u00a0[\u00a0]: Copied! <pre>plot_metrics(\n    metric=\"fidelity_1qb_gates_averaged\",\n    title=\"Single-qubit Gate Fidelities\",\n    xlabel=\"Qubits\",\n    ylabel=\"Fidelities\",\n    data=calibration_data,\n    limits=[0.95, 1],\n)\n</pre> plot_metrics(     metric=\"fidelity_1qb_gates_averaged\",     title=\"Single-qubit Gate Fidelities\",     xlabel=\"Qubits\",     ylabel=\"Fidelities\",     data=calibration_data,     limits=[0.95, 1], ) In\u00a0[\u00a0]: Copied! <pre>plot_metrics(\n    metric=\"cz_gate_fidelity\",\n    title=\"CZ Gate Fidelities\",\n    xlabel=\"Qubit pairs\",\n    ylabel=\"Fidelities\",\n    data=calibration_data,\n    limits=[0.8, 1],\n)\n</pre> plot_metrics(     metric=\"cz_gate_fidelity\",     title=\"CZ Gate Fidelities\",     xlabel=\"Qubit pairs\",     ylabel=\"Fidelities\",     data=calibration_data,     limits=[0.8, 1], ) In\u00a0[\u00a0]: Copied! <pre>plot_metrics(\n    metric=\"fidelity_2qb_cliffords_averaged\",\n    title=\"Two-qubit Gates Cliffords Averaged\",\n    xlabel=\"Qubits\",\n    ylabel=\"Fidelities\",\n    data=calibration_data,\n    limits=[0.7, 1],\n)\n</pre> plot_metrics(     metric=\"fidelity_2qb_cliffords_averaged\",     title=\"Two-qubit Gates Cliffords Averaged\",     xlabel=\"Qubits\",     ylabel=\"Fidelities\",     data=calibration_data,     limits=[0.7, 1], )"},{"location":"examples/visualize_quality_metrics/#visualizing-quality-metrics","title":"Visualizing Quality Metrics\u00b6","text":"<p>A quantum computers performance can change on a regular basis. This can be mitigated to some extent by calibration of the device which generates a calibration set, which is a set of parameters to current operate the quantum computer at. Because of drifts in the environment that the quantum computer operates at, regular calibration is required to account for these drifts and maintain optimal performance.</p> <p>To test the current performance of the calibration, we also benchmark the device, producing a quality metrics set. These benchmarks reflect the current status of the quantum computer and are essential pieces of information for using the system. For example, performance can often be increased by choosing a particular qubit or tunable coupler when running your quantum circuit.</p> <p>This notebook demonstrates how one can read the quality metrics set from the API and visualize it.</p>"},{"location":"examples/visualize_quality_metrics/#importing-libraries","title":"Importing Libraries\u00b6","text":""},{"location":"examples/visualize_quality_metrics/#getting-the-data-from-the-api","title":"Getting the data from the API\u00b6","text":"<p>The calibration set ID and quality metrics set data are bundled together in JSON format available from the Cortex API. In this example, we make a HTTP request to the particular API endpoint, in this case, <code>calibration/metrics/latest</code>. We use the <code>IQMClient</code> to add the authentication token to the request, which is needed for accessing VTT quantum computers.</p> <p>First we define a helper function to get the data. The function <code>get_calibration_data</code> takes input <code>IQMClient</code>, <code>calibration_set_id</code> and optionally a <code>filename</code>. The <code>filename</code> option can be pass to save the data to a json file.</p>"},{"location":"examples/visualize_quality_metrics/#defining-the-iqm-client","title":"Defining the IQM Client\u00b6","text":"<p>Setup the qiskit <code>IQMProvider</code> using the link to backend.</p>"},{"location":"examples/visualize_quality_metrics/#plotting-the-data","title":"Plotting the data\u00b6","text":"<p>To plot the data, we utilise a simple plotting function which can plot a specific metric which we are interested in. The function iterates over the gathered data and extracts the particular keys and values for the input metric. This requires knowing and using the same string as the metric you are interested in.</p>"},{"location":"examples/visualize_quality_metrics/#readout-fidelities","title":"Readout Fidelities\u00b6","text":"<p>The readout fidelity describes how well the quantum computer can measure your quantum state. From the readout fidelity one can see how much error from their quantum circuit they can attribute to incorrectly reading out or measuring the quantum state.</p> <p>Readout fidelity includes both state preparation and measurement errors here.</p> <p>Typical values for readout fidelities are between $94\\%$ and $99\\%$ for VTT quantum computers.</p>"},{"location":"examples/visualize_quality_metrics/#t_1-t_2-times","title":"$T_1$ &amp; $T_2$ Times\u00b6","text":"<p>The $T_1$ and $T_2$ times are the coherence times for the system.</p> <p>The $T_1$ time is called the longitudinal relaxation rate and describes how quickly the excited state of the qubit returns to its ground state.</p> <p>The $T_2$ time is called the transverse relaxation rate and describes loss of coherence of a superposition state.</p> <p>The $T_2$-echo time describes the loss of coherence of the superposition state of the qubit. It is more precise than the $T_2$ Time as it is less susceptible to low-frequency noise.</p> <p>Based on these values you can approximate how many gates you can run on the quantum computer before decoherence occurs, which is an important quantity when writing quantum circuits.</p> <p>Typical values for the coherence times are between $10 \\mu s$ and $60 \\mu s$ for VTT's quantum computers.</p>"},{"location":"examples/visualize_quality_metrics/#single-qubit-gate-fidelities","title":"Single qubit gate fidelities\u00b6","text":"<p>Single qubit gate fidelities are measured through executing the single qubit randomized benchmarking (RB) experiment.</p> <p>In this experiment a random sequence of single-qubit clifford gates are sampled and the survival probabilities are measured. An exponential curve is then fit and an estimate for the average gate fidelity across the set of clifford gates is calculated.</p> <p>It is important to note that single qubit gate fidelities are independent of state preparation and measurement (SPAM) errors.</p> <p>Typical values range between $99.99\\%$ and $99.999\\%$.</p>"},{"location":"examples/visualize_quality_metrics/#two-qubit-gate-fidelities","title":"Two qubit gate fidelities\u00b6","text":"<p>The calibration data reports two metrics for the two-qubit gate fidelity. The CZ gate fidelity and the two-qubit average gate fidelity.</p> <p>The CZ fidelity is estimated using interleaved randomized benchmarking. In this randomized benchmarking sequence is interleaved with the CZ gate, obtaining the average gate fidelity for that specific gate. This is important to know because VTT's quantum computers have their two-qubit native gate as the CZ gate. The fidelity is usually higher than the average 2QB gate fidelity as a random 2QB Clifford transpiles on average to 8.25 1QB gates and 1.5 2QB CZ gates.</p> <p>The 2QB average gate fidelity is estimated with randomized benchmarking protocol in a similar fashion to the single-qubit RB protocol.</p> <p>Typical values are between $97\\%$ and $99\\%$ for CZ gate fidelities and $93\\%$ and $96\\%$ for two-qubit RB.</p>"},{"location":"examples/visualize_quality_metrics/#software-versions","title":"Software versions\u00b6","text":"<pre>cirq-iqm==12.2\niqm-client==15.3\niqm-cortex-cli==5.8\nqiskit-iqm==11.10\n</pre>"}]}